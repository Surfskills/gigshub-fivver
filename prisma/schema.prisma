generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("PRISMA_DATABASE_URL")
  directUrl = env("DATABASE_URL")
}

enum Platform {
  fiverr
  upwork
  direct
}

enum AccountStatus {
  active
  paused
  risk
}

enum AccountLevel {
  starter
  level1
  level2
  proRated
  fivverVetted
}

enum GigStatus {
  active
  paused
  deprecated
}

enum RatingType {
  client
  paypal
  cash
}

enum Shift {
  AM
  PM
}

enum ExpenditureType {
  internet
  rent
  proxy
  electricity
  water
  meals
  office_furniture
  electronics
}

enum PaymentGateway {
  bank
  paypal
  payoneer
}

enum UserRole {
  admin
  operator
}

model User {
  id                  String        @id @default(cuid())
  clerkId             String        @unique // or supabaseId
  email               String        @unique
  name                String
  role                UserRole      @default(operator)
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  
  accountsCreated     Account[]
  shiftReports        ShiftReport[]   @relation("ReportedBy")
  reportsHandedOverTo ShiftReport[]  @relation("HandedOverTo")
  
  @@index([clerkId])
}

model Account {
  id               String        @id @default(cuid())
  platform         Platform
  email            String
  username         String
  typeOfGigs       String        // e.g., "API Development, MVP Building"
  currency         String        @default("USD")
  status           AccountStatus @default(active)
  accountLevel     AccountLevel  @default(starter)
  successRate      Decimal?      @db.Decimal(5, 2)  // 0-100 percentage
  browserType      String?       // e.g., Chrome, Firefox, Safari
  proxy            String?       // proxy configuration/info
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  createdByUserId  String?
  
  createdBy        User?         @relation(fields: [createdByUserId], references: [id])
  gigs             Gig[]
  shiftReports     ShiftReport[]
  withdraws        Withdraw[]
  payoutDetail     PayoutDetail?
  
  @@unique([platform, email])
  @@index([status])
  @@index([createdByUserId])
}

model Withdraw {
  id            String   @id @default(cuid())
  accountId     String
  amount        Decimal  @db.Decimal(10, 2)
  withdrawDate  DateTime @db.Date
  paymentMeans  String
  notes         String?  @db.Text
  createdAt     DateTime @default(now())
  
  account       Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  @@index([accountId])
  @@index([withdrawDate])
}

model Expenditure {
  id               String         @id @default(cuid())
  itemName         String
  typeOfExpenditure ExpenditureType
  cost             Decimal        @db.Decimal(10, 2)
  transactionId    String?
  createdAt        DateTime       @default(now())
  
  @@index([typeOfExpenditure])
  @@index([createdAt])
}

model PayoutDetail {
  id              String         @id @default(cuid())
  accountId       String         @unique
  paymentGateway  PaymentGateway
  mobileNumber    String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  account         Account        @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  @@index([accountId])
}

model Gig {
  id                   String      @id @default(cuid())
  accountId            String
  name                 String
  type                 String      // API, MVP, CICD, etc.
  rated                Boolean     @default(false)
  lastRatedDate        DateTime?   @db.Date   // when gig was last rated
  nextPossibleRateDate DateTime?   @db.Date   // next date it can be rated (interval)
  ratingType           RatingType? // client, paypal, or cash
  ratingEmail          String?     @db.VarChar(255) // required when ratingType is paypal
  status               GigStatus   @default(active)
  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt
  
  account              Account     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  @@index([accountId])
  @@index([status])
}

model ShiftReport {
  id                   String    @id @default(cuid())
  accountId            String
  reportDate           DateTime  @db.Date // YYYY-MM-DD only
  shift                Shift
  
  // Metrics
  ordersCompleted      Int       @default(0)
  pendingOrders        Int       @default(0)
  availableBalance     Decimal   @db.Decimal(10, 2)
  pendingBalance       Decimal   @db.Decimal(10, 2)
  ordersInProgressValue Decimal  @db.Decimal(10, 2) @default(0) // Money from orders in progress
  rankingPage          Int?      // nullable if not applicable
  successRate          Decimal?  @db.Decimal(5, 2)  // 0-100 percentage
  responseRate         Decimal?  @db.Decimal(5, 2)  // 0-100 percentage
  earningsToDate       Decimal?  @db.Decimal(10, 2) // Total earnings for account (available + withdrawn)
  notes                String?   @db.Text

  // Handover
  accountsCreated      Json?     // [{ email: string, type: "seller" | "buyer" }]
  rating               Decimal?  @db.Decimal(3, 2)  // e.g. 4.85
  ordersInProgress     Json?     // [{ account: string, deadline: string (ISO), handlerPhone: string }]
  handedOverToUserId   String?   // analyst receiving the report
  
  // Audit
  reportedByUserId     String
  createdAt            DateTime  @default(now())
  
  account              Account   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  reportedBy           User      @relation("ReportedBy", fields: [reportedByUserId], references: [id])
  handedOverTo         User?     @relation("HandedOverTo", fields: [handedOverToUserId], references: [id])
  
  // CRITICAL: Only one report per account per date per shift
  @@unique([accountId, reportDate, shift])
  @@index([reportDate, shift])
  @@index([accountId])
}
