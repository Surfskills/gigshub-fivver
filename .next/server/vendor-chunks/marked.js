"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/marked";
exports.ids = ["vendor-chunks/marked"];
exports.modules = {

/***/ "(action-browser)/./node_modules/marked/lib/marked.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/marked/lib/marked.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hooks: () => (/* binding */ _Hooks),\n/* harmony export */   Lexer: () => (/* binding */ _Lexer),\n/* harmony export */   Marked: () => (/* binding */ Marked),\n/* harmony export */   Parser: () => (/* binding */ _Parser),\n/* harmony export */   Renderer: () => (/* binding */ _Renderer),\n/* harmony export */   Slugger: () => (/* binding */ _Slugger),\n/* harmony export */   TextRenderer: () => (/* binding */ _TextRenderer),\n/* harmony export */   Tokenizer: () => (/* binding */ _Tokenizer),\n/* harmony export */   defaults: () => (/* binding */ _defaults),\n/* harmony export */   getDefaults: () => (/* binding */ _getDefaults),\n/* harmony export */   lexer: () => (/* binding */ lexer),\n/* harmony export */   marked: () => (/* binding */ marked),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseInline: () => (/* binding */ parseInline),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   setOptions: () => (/* binding */ setOptions),\n/* harmony export */   use: () => (/* binding */ use),\n/* harmony export */   walkTokens: () => (/* binding */ walkTokens)\n/* harmony export */ });\n/**\n * marked v7.0.4 - a markdown parser\n * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ /**\n * Gets the original marked default options.\n */ function _getDefaults() {\n    return {\n        async: false,\n        baseUrl: null,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        headerIds: false,\n        headerPrefix: \"\",\n        highlight: null,\n        hooks: null,\n        langPrefix: \"language-\",\n        mangle: false,\n        pedantic: false,\n        renderer: null,\n        sanitize: false,\n        sanitizer: null,\n        silent: false,\n        smartypants: false,\n        tokenizer: null,\n        walkTokens: null,\n        xhtml: false\n    };\n}\nlet _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n/**\n * Helpers\n */ const escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, \"g\");\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\nconst escapeReplacements = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nconst getEscapeReplacement = (ch)=>escapeReplacements[ch];\nfunction escape(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\nfunction unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, (_, n)=>{\n        n = n.toLowerCase();\n        if (n === \"colon\") return \":\";\n        if (n.charAt(0) === \"#\") {\n            return n.charAt(1) === \"x\" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n        }\n        return \"\";\n    });\n}\nconst caret = /(^|[^\\[])\\^/g;\nfunction edit(regex, opt) {\n    regex = typeof regex === \"string\" ? regex : regex.source;\n    opt = opt || \"\";\n    const obj = {\n        replace: (name, val)=>{\n            val = typeof val === \"object\" && \"source\" in val ? val.source : val;\n            val = val.replace(caret, \"$1\");\n            regex = regex.replace(name, val);\n            return obj;\n        },\n        getRegex: ()=>{\n            return new RegExp(regex, opt);\n        }\n    };\n    return obj;\n}\nconst nonWordAndColonTest = /[^\\w:]/g;\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\nfunction cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n        let prot;\n        try {\n            prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, \"\").toLowerCase();\n        } catch (e) {\n            return null;\n        }\n        if (prot.indexOf(\"javascript:\") === 0 || prot.indexOf(\"vbscript:\") === 0 || prot.indexOf(\"data:\") === 0) {\n            return null;\n        }\n    }\n    if (base && !originIndependentUrl.test(href)) {\n        href = resolveUrl(base, href);\n    }\n    try {\n        href = encodeURI(href).replace(/%25/g, \"%\");\n    } catch (e) {\n        return null;\n    }\n    return href;\n}\nconst baseUrls = {};\nconst justDomain = /^[^:]+:\\/*[^/]*$/;\nconst protocol = /^([^:]+:)[\\s\\S]*$/;\nconst domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\nfunction resolveUrl(base, href) {\n    if (!baseUrls[\" \" + base]) {\n        // we can ignore everything in base after the last slash of its path component,\n        // but we might need to add _that_\n        // https://tools.ietf.org/html/rfc3986#section-3\n        if (justDomain.test(base)) {\n            baseUrls[\" \" + base] = base + \"/\";\n        } else {\n            baseUrls[\" \" + base] = rtrim(base, \"/\", true);\n        }\n    }\n    base = baseUrls[\" \" + base];\n    const relativeBase = base.indexOf(\":\") === -1;\n    if (href.substring(0, 2) === \"//\") {\n        if (relativeBase) {\n            return href;\n        }\n        return base.replace(protocol, \"$1\") + href;\n    } else if (href.charAt(0) === \"/\") {\n        if (relativeBase) {\n            return href;\n        }\n        return base.replace(domain, \"$1\") + href;\n    } else {\n        return base + href;\n    }\n}\nconst noopTest = {\n    exec: ()=>null\n};\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str)=>{\n        let escaped = false;\n        let curr = offset;\n        while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n        } else {\n            // add space before unescaped |\n            return \" |\";\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        } else {\n            while(cells.length < count)cells.push(\"\");\n        }\n    }\n    for(; i < cells.length; i++){\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */ function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return \"\";\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while(suffLen < l){\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else if (currChar !== c && invert) {\n            suffLen++;\n        } else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for(let i = 0; i < str.length; i++){\n        if (str[i] === \"\\\\\") {\n            i++;\n        } else if (str[i] === b[0]) {\n            level++;\n        } else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nfunction checkDeprecations(opt, callback) {\n    if (!opt || opt.silent) {\n        return;\n    }\n    if (callback) {\n        console.warn(\"marked(): callback is deprecated since version 5.0.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/using_pro#async\");\n    }\n    if (opt.sanitize || opt.sanitizer) {\n        console.warn(\"marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options\");\n    }\n    if (opt.highlight || opt.langPrefix !== \"language-\") {\n        console.warn(\"marked(): highlight and langPrefix parameters are deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-highlight.\");\n    }\n    if (opt.mangle) {\n        console.warn(\"marked(): mangle parameter is enabled by default, but is deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install https://www.npmjs.com/package/marked-mangle, or disable by setting `{mangle: false}`.\");\n    }\n    if (opt.baseUrl) {\n        console.warn(\"marked(): baseUrl parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-base-url.\");\n    }\n    if (opt.smartypants) {\n        console.warn(\"marked(): smartypants parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-smartypants.\");\n    }\n    if (opt.xhtml) {\n        console.warn(\"marked(): xhtml parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-xhtml.\");\n    }\n    if (opt.headerIds || opt.headerPrefix) {\n        console.warn(\"marked(): headerIds and headerPrefix parameters enabled by default, but are deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install  https://www.npmjs.com/package/marked-gfm-heading-id, or disable by setting `{headerIds: false}`.\");\n    }\n}\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n    if (cap[0].charAt(0) !== \"!\") {\n        lexer.state.inLink = true;\n        const token = {\n            type: \"link\",\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: \"image\",\n        raw,\n        href,\n        title,\n        text: escape(text)\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text.split(\"\\n\").map((node)=>{\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    }).join(\"\\n\");\n}\n/**\n * Tokenizer\n */ class _Tokenizer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, \"\");\n            return {\n                type: \"code\",\n                raw: cap[0],\n                codeBlockStyle: \"indented\",\n                text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || \"\");\n            return {\n                type: \"code\",\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, \"$1\") : cap[2],\n                text\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, \"#\");\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: \"hr\",\n                raw: cap[0]\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ *>[ \\t]?/gm, \"\");\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            const tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: \"blockquote\",\n                raw: cap[0],\n                tokens,\n                text\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: \"list\",\n                raw: \"\",\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : \"\",\n                loose: false,\n                items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : \"[*+-]\";\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let raw = \"\";\n            let itemContents = \"\";\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while(src){\n                let endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) {\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, (t)=>\" \".repeat(3 * t.length));\n                let nextLine = src.split(\"\\n\", 1)[0];\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimLeft();\n                } else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                let blankLine = false;\n                if (!line && /^ *$/.test(nextLine)) {\n                    raw += nextLine + \"\\n\";\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    // Check if following lines should be included in List Item\n                    while(src){\n                        const rawLine = src.split(\"\\n\", 1)[0];\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {\n                            itemContents += \"\\n\" + nextLine.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) {\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += \"\\n\" + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) {\n                            blankLine = true;\n                        }\n                        raw += rawLine + \"\\n\";\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else if (/\\n *\\n *$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== \"[ ] \";\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                    }\n                }\n                list.items.push({\n                    type: \"list_item\",\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: []\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimRight();\n            list.items[list.items.length - 1].text = itemContents.trimRight();\n            list.raw = list.raw.trimRight();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for(let i = 0; i < list.items.length; i++){\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter((t)=>t.type === \"space\");\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>/\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for(let i = 0; i < list.items.length; i++){\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: \"html\",\n                block: true,\n                raw: cap[0],\n                pre: !this.options.sanitizer && (cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\"),\n                text: cap[0]\n            };\n            if (this.options.sanitize) {\n                const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);\n                const paragraph = token;\n                paragraph.type = \"paragraph\";\n                paragraph.text = text;\n                paragraph.tokens = this.lexer.inline(text);\n            }\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline._escapes, \"$1\") : \"\";\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, \"$1\") : cap[3];\n            return {\n                type: \"def\",\n                tag,\n                raw: cap[0],\n                href,\n                title\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (cap) {\n            const item = {\n                type: \"table\",\n                raw: cap[0],\n                header: splitCells(cap[1]).map((c)=>{\n                    return {\n                        text: c,\n                        tokens: []\n                    };\n                }),\n                align: cap[2].replace(/^ *|\\| *$/g, \"\").split(/ *\\| */),\n                rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : []\n            };\n            if (item.header.length === item.align.length) {\n                let l = item.align.length;\n                let i, j, k, row;\n                for(i = 0; i < l; i++){\n                    const align = item.align[i];\n                    if (align) {\n                        if (/^ *-+: *$/.test(align)) {\n                            item.align[i] = \"right\";\n                        } else if (/^ *:-+: *$/.test(align)) {\n                            item.align[i] = \"center\";\n                        } else if (/^ *:-+ *$/.test(align)) {\n                            item.align[i] = \"left\";\n                        } else {\n                            item.align[i] = null;\n                        }\n                    }\n                }\n                l = item.rows.length;\n                for(i = 0; i < l; i++){\n                    item.rows[i] = splitCells(item.rows[i], item.header.length).map((c)=>{\n                        return {\n                            text: c,\n                            tokens: []\n                        };\n                    });\n                }\n                // parse child tokens inside headers and cells\n                // header child tokens\n                l = item.header.length;\n                for(j = 0; j < l; j++){\n                    item.header[j].tokens = this.lexer.inline(item.header[j].text);\n                }\n                // cell child tokens\n                l = item.rows.length;\n                for(j = 0; j < l; j++){\n                    row = item.rows[j];\n                    for(k = 0; k < row.length; k++){\n                        row[k].tokens = this.lexer.inline(row[k].text);\n                    }\n                }\n                return item;\n            }\n        }\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n                type: \"paragraph\",\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: \"escape\",\n                raw: cap[0],\n                text: escape(cap[1])\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: this.options.sanitize ? \"text\" : \"html\",\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!/>$/.test(trimmedUrl)) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = \"\";\n                }\n            }\n            let href = cap[2];\n            let title = \"\";\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline._escapes, \"$1\") : href,\n                title: title ? title.replace(this.rules.inline._escapes, \"$1\") : title\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            let link = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n            link = links[link.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: \"text\",\n                    raw: text,\n                    text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = \"\") {\n        let match = this.rules.inline.emStrong.lDelim.exec(src);\n        if (!match) return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n        const nextChar = match[1] || match[2] || \"\";\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [\n                ...match[0]\n            ].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while((match = endReg.exec(maskedSrc)) != null){\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim) continue; // skip single * in __abc*abc__\n                rLength = [\n                    ...rDelim\n                ].length;\n                if (match[3] || match[4]) {\n                    delimTotal += rLength;\n                    continue;\n                } else if (match[5] || match[6]) {\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                const raw = [\n                    ...src\n                ].slice(0, lLength + match.index + rLength + 1).join(\"\");\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: \"em\",\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: \"strong\",\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, \" \");\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n                type: \"codespan\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    }\n    autolink(src, mangle) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n                href = \"mailto:\" + text;\n            } else {\n                text = escape(cap[1]);\n                href = text;\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    url(src, mangle) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n                href = \"mailto:\" + text;\n            } else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n                }while (prevCapZero !== cap[0]);\n                text = escape(cap[0]);\n                if (cap[1] === \"www.\") {\n                    href = \"http://\" + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    inlineText(src, smartypants) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];\n            } else {\n                text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n            }\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n}\n/**\n * Block-Level Grammar\n */ // Not all rules are defined in the object literal\n// @ts-expect-error\nconst block = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n    hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n    html: \"^ {0,3}(?:\" // optional indentation\n     + \"<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)\" // (1)\n     + \"|comment[^\\\\n]*(\\\\n+|$)\" // (2)\n     + \"|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)\" // (3)\n     + \"|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)\" // (4)\n     + \"|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)\" // (5)\n     + \"|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (6)\n     + \"|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) open tag\n     + \"|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) closing tag\n     + \")\",\n    def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noopTest,\n    lheading: /^((?:(?!^bull ).|\\n(?!\\n|bull ))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n};\nblock._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def).replace(\"label\", block._label).replace(\"title\", block._title).getRegex();\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.listItemStart = edit(/^( *)(bull) */).replace(\"bull\", block.bullet).getRegex();\nblock.list = edit(block.list).replace(/bull/g, block.bullet).replace(\"hr\", \"\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))\").replace(\"def\", \"\\\\n+(?=\" + block.def.source + \")\").getRegex();\nblock._tag = \"address|article|aside|base|basefont|blockquote|body|caption\" + \"|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption\" + \"|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe\" + \"|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option\" + \"|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr\" + \"|track|ul\";\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, \"i\").replace(\"comment\", block._comment).replace(\"tag\", block._tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\nblock.lheading = edit(block.lheading).replace(/bull/g, block.bullet) // lists can interrupt\n.getRegex();\nblock.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\nblock.blockquote = edit(block.blockquote).replace(\"paragraph\", block.paragraph).getRegex();\n/**\n * Normal Block Grammar\n */ block.normal = {\n    ...block\n};\n/**\n * GFM Block Grammar\n */ block.gfm = {\n    ...block.normal,\n    table: \"^ *([^\\\\n ].*\\\\|.*)\\\\n\" // Header\n     + \" {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?\" // Align\n     + \"(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\" // Cells\n};\nblock.gfm.table = edit(block.gfm.table).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \" {4}[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // tables can be interrupted by type (6) html blocks\n.getRegex();\nblock.gfm.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"table\", block.gfm.table) // interrupt paragraphs with table\n.replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */ block.pedantic = {\n    ...block.normal,\n    html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)\" + \"|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)\" // closed tag\n     + \"|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", block._comment).replace(/tag/g, \"(?!(?:\" + \"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub\" + \"|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\" + \"\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(block.normal._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", block.lheading).replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").getRegex()\n};\n/**\n * Inline-Level Grammar\n */ // Not all rules are defined in the object literal\n// @ts-expect-error\nconst inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest,\n    tag: \"^comment\" + \"|^</[a-zA-Z][\\\\w:-]*\\\\s*>\" // self-closing tag\n     + \"|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>\" // open tag\n     + \"|^<\\\\?[\\\\s\\\\S]*?\\\\?>\" // processing instruction, e.g. <?php ?>\n     + \"|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>\" // declaration, e.g. <!DOCTYPE html>\n     + \"|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\",\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n    nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n    reflinkSearch: \"reflink|nolink(?!\\\\()\",\n    emStrong: {\n        lDelim: /^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/,\n        //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n        //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a\n        rDelimAst: /^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])/,\n        rDelimUnd: /^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/ // ^- Not allowed for _\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^((?![*_])[\\spunctuation])/\n};\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\ninline._punctuation = \"\\\\p{P}$+<=>`^|~\";\ninline.punctuation = edit(inline.punctuation, \"u\").replace(/punctuation/g, inline._punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\ninline.blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\ninline.anyPunctuation = /\\\\[punct]/g;\ninline._escapes = /\\\\([punct])/g;\ninline._comment = edit(block._comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\ninline.emStrong.lDelim = edit(inline.emStrong.lDelim, \"u\").replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline.anyPunctuation = edit(inline.anyPunctuation, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline._escapes = edit(inline._escapes, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink).replace(\"scheme\", inline._scheme).replace(\"email\", inline._email).getRegex();\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\ninline.tag = edit(inline.tag).replace(\"comment\", inline._comment).replace(\"attribute\", inline._attribute).getRegex();\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\ninline.link = edit(inline.link).replace(\"label\", inline._label).replace(\"href\", inline._href).replace(\"title\", inline._title).getRegex();\ninline.reflink = edit(inline.reflink).replace(\"label\", inline._label).replace(\"ref\", block._label).getRegex();\ninline.nolink = edit(inline.nolink).replace(\"ref\", block._label).getRegex();\ninline.reflinkSearch = edit(inline.reflinkSearch, \"g\").replace(\"reflink\", inline.reflink).replace(\"nolink\", inline.nolink).getRegex();\n/**\n * Normal Inline Grammar\n */ inline.normal = {\n    ...inline\n};\n/**\n * Pedantic Inline Grammar\n */ inline.pedantic = {\n    ...inline.normal,\n    strong: {\n        start: /^__|\\*\\*/,\n        middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n        endAst: /\\*\\*(?!\\*)/g,\n        endUnd: /__(?!_)/g\n    },\n    em: {\n        start: /^_|\\*/,\n        middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n        endAst: /\\*(?!\\*)/g,\n        endUnd: /_(?!_)/g\n    },\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", inline._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", inline._label).getRegex()\n};\n/**\n * GFM Inline Grammar\n */ inline.gfm = {\n    ...inline.normal,\n    escape: edit(inline.escape).replace(\"])\", \"~|])\").getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\ninline.gfm.url = edit(inline.gfm.url, \"i\").replace(\"email\", inline.gfm._extended_email).getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */ inline.breaks = {\n    ...inline.gfm,\n    br: edit(inline.br).replace(\"{2,}\", \"*\").getRegex(),\n    text: edit(inline.gfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n};\n/**\n * smartypants text replacement\n */ function smartypants(text) {\n    return text// em-dashes\n    .replace(/---/g, \"—\")// en-dashes\n    .replace(/--/g, \"–\")// opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1‘\")// closing singles & apostrophes\n    .replace(/'/g, \"’\")// opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1“\")// closing doubles\n    .replace(/\"/g, \"”\")// ellipses\n    .replace(/\\.{3}/g, \"…\");\n}\n/**\n * mangle email addresses\n */ function mangle(text) {\n    let out = \"\";\n    for(let i = 0; i < text.length; i++){\n        const ch = Math.random() > 0.5 ? \"x\" + text.charCodeAt(i).toString(16) : text.charCodeAt(i).toString();\n        out += \"&#\" + ch + \";\";\n    }\n    return out;\n}\n/**\n * Block Lexer\n */ class _Lexer {\n    constructor(options){\n        // TokenList cannot be created in one go\n        // @ts-expect-error\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            } else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */ static get rules() {\n        return {\n            block,\n            inline\n        };\n    }\n    /**\n     * Static Lex Method\n     */ static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */ static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */ lex(src) {\n        src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n        this.blockTokens(src, this.tokens);\n        let next;\n        while(next = this.inlineQueue.shift()){\n            this.inlineTokens(next.src, next.tokens);\n        }\n        return this.tokens;\n    }\n    blockTokens(src, tokens = []) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n        } else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs)=>{\n                return leading + \"    \".repeat(tabs.length);\n            });\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        let lastParagraphClipped;\n        while(src){\n            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unecessary paragraph tags\n                    tokens[tokens.length - 1].raw += \"\\n\";\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === \"paragraph\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({\n            src,\n            tokens\n        });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */ inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){\n                    if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while(src){\n            if (!keepPrevChar) {\n                prevChar = \"\";\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src, mangle)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== \"_\") {\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n/**\n * Renderer\n */ class _Renderer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    code(code, infostring, escaped) {\n        const lang = (infostring || \"\").match(/^\\S*/)?.[0];\n        if (this.options.highlight) {\n            const out = this.options.highlight(code, lang);\n            if (out != null && out !== code) {\n                escaped = true;\n                code = out;\n            }\n        }\n        code = code.replace(/\\n$/, \"\") + \"\\n\";\n        if (!lang) {\n            return \"<pre><code>\" + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n        }\n        return '<pre><code class=\"' + this.options.langPrefix + escape(lang) + '\">' + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n    }\n    blockquote(quote) {\n        return `<blockquote>\\n${quote}</blockquote>\\n`;\n    }\n    html(html, block) {\n        return html;\n    }\n    heading(text, level, raw, slugger) {\n        if (this.options.headerIds) {\n            const id = this.options.headerPrefix + slugger.slug(raw);\n            return `<h${level} id=\"${id}\">${text}</h${level}>\\n`;\n        }\n        // ignore IDs\n        return `<h${level}>${text}</h${level}>\\n`;\n    }\n    hr() {\n        return this.options.xhtml ? \"<hr/>\\n\" : \"<hr>\\n\";\n    }\n    list(body, ordered, start) {\n        const type = ordered ? \"ol\" : \"ul\";\n        const startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n        return \"<\" + type + startatt + \">\\n\" + body + \"</\" + type + \">\\n\";\n    }\n    listitem(text, task, checked) {\n        return `<li>${text}</li>\\n`;\n    }\n    checkbox(checked) {\n        return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? \" /\" : \"\") + \"> \";\n    }\n    paragraph(text) {\n        return `<p>${text}</p>\\n`;\n    }\n    table(header, body) {\n        if (body) body = `<tbody>${body}</tbody>`;\n        return \"<table>\\n\" + \"<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n    }\n    tablerow(content) {\n        return `<tr>\\n${content}</tr>\\n`;\n    }\n    tablecell(content, flags) {\n        const type = flags.header ? \"th\" : \"td\";\n        const tag = flags.align ? `<${type} align=\"${flags.align}\">` : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */ strong(text) {\n        return `<strong>${text}</strong>`;\n    }\n    em(text) {\n        return `<em>${text}</em>`;\n    }\n    codespan(text) {\n        return `<code>${text}</code>`;\n    }\n    br() {\n        return this.options.xhtml ? \"<br/>\" : \"<br>\";\n    }\n    del(text) {\n        return `<del>${text}</del>`;\n    }\n    link(href, title, text) {\n        const cleanHref = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += \">\" + text + \"</a>\";\n        return out;\n    }\n    image(href, title, text) {\n        const cleanHref = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += this.options.xhtml ? \"/>\" : \">\";\n        return out;\n    }\n    text(text) {\n        return text;\n    }\n}\n/**\n * TextRenderer\n * returns only the textual part of the token\n */ class _TextRenderer {\n    // no need for block level renderers\n    strong(text) {\n        return text;\n    }\n    em(text) {\n        return text;\n    }\n    codespan(text) {\n        return text;\n    }\n    del(text) {\n        return text;\n    }\n    html(text) {\n        return text;\n    }\n    text(text) {\n        return text;\n    }\n    link(href, title, text) {\n        return \"\" + text;\n    }\n    image(href, title, text) {\n        return \"\" + text;\n    }\n    br() {\n        return \"\";\n    }\n}\n/**\n * Slugger generates header id\n */ class _Slugger {\n    constructor(){\n        this.seen = {};\n    }\n    serialize(value) {\n        return value.toLowerCase().trim()// remove html tags\n        .replace(/<[!\\/a-z].*?>/ig, \"\")// remove unwanted chars\n        .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, \"\").replace(/\\s/g, \"-\");\n    }\n    /**\n     * Finds the next safe (unique) slug to use\n     */ getNextSafeSlug(originalSlug, isDryRun) {\n        let slug = originalSlug;\n        let occurenceAccumulator = 0;\n        if (this.seen.hasOwnProperty(slug)) {\n            occurenceAccumulator = this.seen[originalSlug];\n            do {\n                occurenceAccumulator++;\n                slug = originalSlug + \"-\" + occurenceAccumulator;\n            }while (this.seen.hasOwnProperty(slug));\n        }\n        if (!isDryRun) {\n            this.seen[originalSlug] = occurenceAccumulator;\n            this.seen[slug] = 0;\n        }\n        return slug;\n    }\n    /**\n     * Convert string to unique id\n     */ slug(value, options = {}) {\n        const slug = this.serialize(value);\n        return this.getNextSafeSlug(slug, options.dryrun);\n    }\n}\n/**\n * Parsing & Compiling\n */ class _Parser {\n    constructor(options){\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new _TextRenderer();\n        this.slugger = new _Slugger();\n    }\n    /**\n     * Static Parse Method\n     */ static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */ static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */ parse(tokens, top = true) {\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const genericToken = token;\n                const ret = this.options.extensions.renderers[genericToken.type].call({\n                    parser: this\n                }, genericToken);\n                if (ret !== false || ![\n                    \"space\",\n                    \"hr\",\n                    \"heading\",\n                    \"code\",\n                    \"table\",\n                    \"blockquote\",\n                    \"list\",\n                    \"html\",\n                    \"paragraph\",\n                    \"text\"\n                ].includes(genericToken.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"space\":\n                    {\n                        continue;\n                    }\n                case \"hr\":\n                    {\n                        out += this.renderer.hr();\n                        continue;\n                    }\n                case \"heading\":\n                    {\n                        const headingToken = token;\n                        out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)), this.slugger);\n                        continue;\n                    }\n                case \"code\":\n                    {\n                        const codeToken = token;\n                        out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);\n                        continue;\n                    }\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        let header = \"\";\n                        // header\n                        let cell = \"\";\n                        for(let j = 0; j < tableToken.header.length; j++){\n                            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), {\n                                header: true,\n                                align: tableToken.align[j]\n                            });\n                        }\n                        header += this.renderer.tablerow(cell);\n                        let body = \"\";\n                        for(let j = 0; j < tableToken.rows.length; j++){\n                            const row = tableToken.rows[j];\n                            cell = \"\";\n                            for(let k = 0; k < row.length; k++){\n                                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                                    header: false,\n                                    align: tableToken.align[k]\n                                });\n                            }\n                            body += this.renderer.tablerow(cell);\n                        }\n                        out += this.renderer.table(header, body);\n                        continue;\n                    }\n                case \"blockquote\":\n                    {\n                        const blockquoteToken = token;\n                        const body = this.parse(blockquoteToken.tokens);\n                        out += this.renderer.blockquote(body);\n                        continue;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        const ordered = listToken.ordered;\n                        const start = listToken.start;\n                        const loose = listToken.loose;\n                        let body = \"\";\n                        for(let j = 0; j < listToken.items.length; j++){\n                            const item = listToken.items[j];\n                            const checked = item.checked;\n                            const task = item.task;\n                            let itemBody = \"\";\n                            if (item.task) {\n                                const checkbox = this.renderer.checkbox(!!checked);\n                                if (loose) {\n                                    if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                                        item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                                            item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                                        }\n                                    } else {\n                                        item.tokens.unshift({\n                                            type: \"text\",\n                                            text: checkbox\n                                        });\n                                    }\n                                } else {\n                                    itemBody += checkbox;\n                                }\n                            }\n                            itemBody += this.parse(item.tokens, loose);\n                            body += this.renderer.listitem(itemBody, task, !!checked);\n                        }\n                        out += this.renderer.list(body, ordered, start);\n                        continue;\n                    }\n                case \"html\":\n                    {\n                        const htmlToken = token;\n                        out += this.renderer.html(htmlToken.text, htmlToken.block);\n                        continue;\n                    }\n                case \"paragraph\":\n                    {\n                        const paragraphToken = token;\n                        out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                        continue;\n                    }\n                case \"text\":\n                    {\n                        let textToken = token;\n                        let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                        while(i + 1 < tokens.length && tokens[i + 1].type === \"text\"){\n                            textToken = tokens[++i];\n                            body += \"\\n\" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                        }\n                        out += top ? this.renderer.paragraph(body) : body;\n                        continue;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */ parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const ret = this.options.extensions.renderers[token.type].call({\n                    parser: this\n                }, token);\n                if (ret !== false || ![\n                    \"escape\",\n                    \"html\",\n                    \"link\",\n                    \"image\",\n                    \"strong\",\n                    \"em\",\n                    \"codespan\",\n                    \"br\",\n                    \"del\",\n                    \"text\"\n                ].includes(token.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"escape\":\n                    {\n                        const escapeToken = token;\n                        out += renderer.text(escapeToken.text);\n                        break;\n                    }\n                case \"html\":\n                    {\n                        const tagToken = token;\n                        out += renderer.html(tagToken.text);\n                        break;\n                    }\n                case \"link\":\n                    {\n                        const linkToken = token;\n                        out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                        break;\n                    }\n                case \"image\":\n                    {\n                        const imageToken = token;\n                        out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                        break;\n                    }\n                case \"strong\":\n                    {\n                        const strongToken = token;\n                        out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                        break;\n                    }\n                case \"em\":\n                    {\n                        const emToken = token;\n                        out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                        break;\n                    }\n                case \"codespan\":\n                    {\n                        const codespanToken = token;\n                        out += renderer.codespan(codespanToken.text);\n                        break;\n                    }\n                case \"br\":\n                    {\n                        out += renderer.br();\n                        break;\n                    }\n                case \"del\":\n                    {\n                        const delToken = token;\n                        out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                        break;\n                    }\n                case \"text\":\n                    {\n                        const textToken = token;\n                        out += renderer.text(textToken.text);\n                        break;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n}\nclass _Hooks {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    static{\n        this.passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\"\n        ]);\n    }\n    /**\n     * Process markdown before marked\n     */ preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */ postprocess(html) {\n        return html;\n    }\n}\nclass Marked {\n    constructor(...args){\n        this.defaults = _getDefaults();\n        this.options = this.setOptions;\n        this.parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n        this.parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n        this.Parser = _Parser;\n        this.parser = _Parser.parse;\n        this.Renderer = _Renderer;\n        this.TextRenderer = _TextRenderer;\n        this.Lexer = _Lexer;\n        this.lexer = _Lexer.lex;\n        this.Tokenizer = _Tokenizer;\n        this.Slugger = _Slugger;\n        this.Hooks = _Hooks;\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */ walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens){\n            values = values.concat(callback.call(this, token));\n            switch(token.type){\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        for (const cell of tableToken.header){\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows){\n                            for (const cell of row){\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                default:\n                    {\n                        const genericToken = token;\n                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                values = values.concat(this.walkTokens(genericToken[childTokens], callback));\n                            });\n                        } else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || {\n            renderers: {},\n            childTokens: {}\n        };\n        args.forEach((pack)=>{\n            // copy options to new object\n            const opts = {\n                ...pack\n            };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext)=>{\n                    if (!ext.name) {\n                        throw new Error(\"extension name required\");\n                    }\n                    if (\"renderer\" in ext) {\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        } else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if (\"tokenizer\" in ext) {\n                        if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        } else {\n                            extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                        }\n                        if (ext.start) {\n                            if (ext.level === \"block\") {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                } else {\n                                    extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                }\n                            } else if (ext.level === \"inline\") {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                } else {\n                                    extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                    }\n                    if (\"childTokens\" in ext && ext.childTokens) {\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for(const prop in pack.renderer){\n                    const rendererFunc = pack.renderer[prop];\n                    const rendererKey = prop;\n                    const prevRenderer = renderer[rendererKey];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererKey] = (...args)=>{\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || \"\";\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for(const prop in pack.tokenizer){\n                    const tokenizerFunc = pack.tokenizer[prop];\n                    const tokenizerKey = prop;\n                    const prevTokenizer = tokenizer[tokenizerKey];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    tokenizer[tokenizerKey] = (...args)=>{\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for(const prop in pack.hooks){\n                    const hooksFunc = pack.hooks[prop];\n                    const hooksKey = prop;\n                    const prevHook = hooks[hooksKey];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        hooks[hooksKey] = (arg)=>{\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        hooks[hooksKey] = (...args)=>{\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function(token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = {\n                ...this.defaults,\n                ...opts\n            };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = {\n            ...this.defaults,\n            ...opt\n        };\n        return this;\n    }\n    #parseMarkdown(lexer, parser) {\n        return (src, optOrCallback, callback)=>{\n            if (typeof optOrCallback === \"function\") {\n                callback = optOrCallback;\n                optOrCallback = null;\n            }\n            const origOpt = {\n                ...optOrCallback\n            };\n            const opt = {\n                ...this.defaults,\n                ...origOpt\n            };\n            // Show warning if an extension set async to true but the parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                if (!opt.silent) {\n                    console.warn(\"marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.\");\n                }\n                opt.async = true;\n            }\n            const throwError = this.#onError(!!opt.silent, !!opt.async, callback);\n            // throw error in case of non string input\n            if (typeof src === \"undefined\" || src === null) {\n                return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n            }\n            if (typeof src !== \"string\") {\n                return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n            }\n            checkDeprecations(opt, callback);\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n            }\n            if (callback) {\n                const resultCallback = callback;\n                const highlight = opt.highlight;\n                let tokens;\n                try {\n                    if (opt.hooks) {\n                        src = opt.hooks.preprocess(src);\n                    }\n                    tokens = lexer(src, opt);\n                } catch (e) {\n                    return throwError(e);\n                }\n                const done = (err)=>{\n                    let out;\n                    if (!err) {\n                        try {\n                            if (opt.walkTokens) {\n                                this.walkTokens(tokens, opt.walkTokens);\n                            }\n                            out = parser(tokens, opt);\n                            if (opt.hooks) {\n                                out = opt.hooks.postprocess(out);\n                            }\n                        } catch (e) {\n                            err = e;\n                        }\n                    }\n                    opt.highlight = highlight;\n                    return err ? throwError(err) : resultCallback(null, out);\n                };\n                if (!highlight || highlight.length < 3) {\n                    return done();\n                }\n                delete opt.highlight;\n                if (!tokens.length) return done();\n                let pending = 0;\n                this.walkTokens(tokens, (token)=>{\n                    if (token.type === \"code\") {\n                        pending++;\n                        setTimeout(()=>{\n                            highlight(token.text, token.lang, (err, code)=>{\n                                if (err) {\n                                    return done(err);\n                                }\n                                if (code != null && code !== token.text) {\n                                    token.text = code;\n                                    token.escaped = true;\n                                }\n                                pending--;\n                                if (pending === 0) {\n                                    done();\n                                }\n                            });\n                        }, 0);\n                    }\n                });\n                if (pending === 0) {\n                    done();\n                }\n                return;\n            }\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                const tokens = lexer(src, opt);\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            } catch (e) {\n                return throwError(e);\n            }\n        };\n    }\n    #onError(silent, async, callback) {\n        return (e)=>{\n            e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n            if (silent) {\n                const msg = \"<p>An error occurred:</p><pre>\" + escape(e.message + \"\", true) + \"</pre>\";\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                if (callback) {\n                    callback(null, msg);\n                    return;\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            if (callback) {\n                callback(e);\n                return;\n            }\n            throw e;\n        };\n    }\n}\nconst markedInstance = new Marked();\nfunction marked(src, opt, callback) {\n    return markedInstance.parse(src, opt, callback);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */ marked.options = marked.setOptions = function(options) {\n    markedInstance.setOptions(options);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Gets the original marked default options.\n */ marked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */ marked.use = function(...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */ marked.walkTokens = function(tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */ marked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */ marked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Slugger = _Slugger;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n //# sourceMappingURL=marked.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FFRDs7O0NBR0MsR0FFRDs7Q0FFQyxHQUNELFNBQVNBO0lBQ0wsT0FBTztRQUNIQyxPQUFPO1FBQ1BDLFNBQVM7UUFDVEMsUUFBUTtRQUNSQyxZQUFZO1FBQ1pDLEtBQUs7UUFDTEMsV0FBVztRQUNYQyxjQUFjO1FBQ2RDLFdBQVc7UUFDWEMsT0FBTztRQUNQQyxZQUFZO1FBQ1pDLFFBQVE7UUFDUkMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFVBQVU7UUFDVkMsV0FBVztRQUNYQyxRQUFRO1FBQ1JDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxZQUFZO1FBQ1pDLE9BQU87SUFDWDtBQUNKO0FBQ0EsSUFBSUMsWUFBWXJCO0FBQ2hCLFNBQVNzQixlQUFlQyxXQUFXO0lBQy9CRixZQUFZRTtBQUNoQjtBQUVBOztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxnQkFBZ0IsSUFBSUMsT0FBT0YsV0FBV0csTUFBTSxFQUFFO0FBQ3BELE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyx3QkFBd0IsSUFBSUgsT0FBT0UsbUJBQW1CRCxNQUFNLEVBQUU7QUFDcEUsTUFBTUcscUJBQXFCO0lBQ3ZCLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0FBQ1Q7QUFDQSxNQUFNQyx1QkFBdUIsQ0FBQ0MsS0FBT0Ysa0JBQWtCLENBQUNFLEdBQUc7QUFDM0QsU0FBU0MsT0FBT0MsSUFBSSxFQUFFQyxNQUFNO0lBQ3hCLElBQUlBLFFBQVE7UUFDUixJQUFJWCxXQUFXWSxJQUFJLENBQUNGLE9BQU87WUFDdkIsT0FBT0EsS0FBS0csT0FBTyxDQUFDWixlQUFlTTtRQUN2QztJQUNKLE9BQ0s7UUFDRCxJQUFJSCxtQkFBbUJRLElBQUksQ0FBQ0YsT0FBTztZQUMv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LFNBQVVrRyxNQUFNLEVBQUVkLFFBQVE7SUFDMUMsT0FBT3FTLGVBQWV6WCxVQUFVLENBQUNrRyxRQUFRZDtBQUM3QztBQUNBOzs7Ozs7Q0FNQyxHQUNEc1MsT0FBT2xGLFdBQVcsR0FBR2lGLGVBQWVqRixXQUFXO0FBQy9DOztDQUVDLEdBQ0RrRixPQUFPaEQsTUFBTSxHQUFHdEM7QUFDaEJzRixPQUFPbkYsTUFBTSxHQUFHSCxRQUFRRSxLQUFLO0FBQzdCb0YsT0FBTy9DLFFBQVEsR0FBR2xFO0FBQ2xCaUgsT0FBTzlDLFlBQVksR0FBR25EO0FBQ3RCaUcsT0FBTzdDLEtBQUssR0FBR2pHO0FBQ2Y4SSxPQUFPL1IsS0FBSyxHQUFHaUosT0FBT0ksR0FBRztBQUN6QjBJLE9BQU81QyxTQUFTLEdBQUdsTztBQUNuQjhRLE9BQU8zQyxPQUFPLEdBQUdyRDtBQUNqQmdHLE9BQU8xQyxLQUFLLEdBQUdqQjtBQUNmMkQsT0FBT3BGLEtBQUssR0FBR29GO0FBQ2YsTUFBTTVRLFVBQVU0USxPQUFPNVEsT0FBTztBQUM5QixNQUFNME4sYUFBYWtELE9BQU9sRCxVQUFVO0FBQ3BDLE1BQU1TLE1BQU15QyxPQUFPekMsR0FBRztBQUN0QixNQUFNalYsYUFBYTBYLE9BQU8xWCxVQUFVO0FBQ3BDLE1BQU13UyxjQUFja0YsT0FBT2xGLFdBQVc7QUFDdEMsTUFBTUYsUUFBUW9GO0FBQ2QsTUFBTW5GLFNBQVNILFFBQVFFLEtBQUs7QUFDNUIsTUFBTTNNLFFBQVFpSixPQUFPSSxHQUFHO0FBRXdSLENBQ2hULHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZWVsYW5jZS1vcHMtYnJhaW4vLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzP2M3MzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtYXJrZWQgdjcuMC40IC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDIzLCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZFxuICovXG5cbi8qKlxuICogRE8gTk9UIEVESVQgVEhJUyBGSUxFXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gZmlsZXMgaW4gLi9zcmMvXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBtYXJrZWQgZGVmYXVsdCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBfZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICBiYXNlVXJsOiBudWxsLFxuICAgICAgICBicmVha3M6IGZhbHNlLFxuICAgICAgICBleHRlbnNpb25zOiBudWxsLFxuICAgICAgICBnZm06IHRydWUsXG4gICAgICAgIGhlYWRlcklkczogZmFsc2UsXG4gICAgICAgIGhlYWRlclByZWZpeDogJycsXG4gICAgICAgIGhpZ2hsaWdodDogbnVsbCxcbiAgICAgICAgaG9va3M6IG51bGwsXG4gICAgICAgIGxhbmdQcmVmaXg6ICdsYW5ndWFnZS0nLFxuICAgICAgICBtYW5nbGU6IGZhbHNlLFxuICAgICAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgICAgIHJlbmRlcmVyOiBudWxsLFxuICAgICAgICBzYW5pdGl6ZTogZmFsc2UsXG4gICAgICAgIHNhbml0aXplcjogbnVsbCxcbiAgICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICAgICAgc21hcnR5cGFudHM6IGZhbHNlLFxuICAgICAgICB0b2tlbml6ZXI6IG51bGwsXG4gICAgICAgIHdhbGtUb2tlbnM6IG51bGwsXG4gICAgICAgIHhodG1sOiBmYWxzZVxuICAgIH07XG59XG5sZXQgX2RlZmF1bHRzID0gX2dldERlZmF1bHRzKCk7XG5mdW5jdGlvbiBjaGFuZ2VEZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICAgIF9kZWZhdWx0cyA9IG5ld0RlZmF1bHRzO1xufVxuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuY29uc3QgZXNjYXBlVGVzdCA9IC9bJjw+XCInXS87XG5jb25zdCBlc2NhcGVSZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVUZXN0LnNvdXJjZSwgJ2cnKTtcbmNvbnN0IGVzY2FwZVRlc3ROb0VuY29kZSA9IC9bPD5cIiddfCYoPyEoI1xcZHsxLDd9fCNbWHhdW2EtZkEtRjAtOV17MSw2fXxcXHcrKTspLztcbmNvbnN0IGVzY2FwZVJlcGxhY2VOb0VuY29kZSA9IG5ldyBSZWdFeHAoZXNjYXBlVGVzdE5vRW5jb2RlLnNvdXJjZSwgJ2cnKTtcbmNvbnN0IGVzY2FwZVJlcGxhY2VtZW50cyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5Oydcbn07XG5jb25zdCBnZXRFc2NhcGVSZXBsYWNlbWVudCA9IChjaCkgPT4gZXNjYXBlUmVwbGFjZW1lbnRzW2NoXTtcbmZ1bmN0aW9uIGVzY2FwZShodG1sLCBlbmNvZGUpIHtcbiAgICBpZiAoZW5jb2RlKSB7XG4gICAgICAgIGlmIChlc2NhcGVUZXN0LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZXNjYXBlVGVzdE5vRW5jb2RlLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZU5vRW5jb2RlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG59XG5jb25zdCB1bmVzY2FwZVRlc3QgPSAvJigjKD86XFxkKyl8KD86I3hbMC05QS1GYS1mXSspfCg/OlxcdyspKTs/L2lnO1xuZnVuY3Rpb24gdW5lc2NhcGUoaHRtbCkge1xuICAgIC8vIGV4cGxpY2l0bHkgbWF0Y2ggZGVjaW1hbCwgaGV4LCBhbmQgbmFtZWQgSFRNTCBlbnRpdGllc1xuICAgIHJldHVybiBodG1sLnJlcGxhY2UodW5lc2NhcGVUZXN0LCAoXywgbikgPT4ge1xuICAgICAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobiA9PT0gJ2NvbG9uJylcbiAgICAgICAgICAgIHJldHVybiAnOic7XG4gICAgICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICByZXR1cm4gbi5jaGFyQXQoMSkgPT09ICd4J1xuICAgICAgICAgICAgICAgID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKVxuICAgICAgICAgICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbn1cbmNvbnN0IGNhcmV0ID0gLyhefFteXFxbXSlcXF4vZztcbmZ1bmN0aW9uIGVkaXQocmVnZXgsIG9wdCkge1xuICAgIHJlZ2V4ID0gdHlwZW9mIHJlZ2V4ID09PSAnc3RyaW5nJyA/IHJlZ2V4IDogcmVnZXguc291cmNlO1xuICAgIG9wdCA9IG9wdCB8fCAnJztcbiAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIHJlcGxhY2U6IChuYW1lLCB2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICdzb3VyY2UnIGluIHZhbCA/IHZhbC5zb3VyY2UgOiB2YWw7XG4gICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZShjYXJldCwgJyQxJyk7XG4gICAgICAgICAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJlZ2V4OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbn1cbmNvbnN0IG5vbldvcmRBbmRDb2xvblRlc3QgPSAvW15cXHc6XS9nO1xuY29uc3Qgb3JpZ2luSW5kZXBlbmRlbnRVcmwgPSAvXiR8XlthLXpdW2EtejAtOSsuLV0qOnxeWz8jXS9pO1xuZnVuY3Rpb24gY2xlYW5Vcmwoc2FuaXRpemUsIGJhc2UsIGhyZWYpIHtcbiAgICBpZiAoc2FuaXRpemUpIHtcbiAgICAgICAgbGV0IHByb3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm90ID0gZGVjb2RlVVJJQ29tcG9uZW50KHVuZXNjYXBlKGhyZWYpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5vbldvcmRBbmRDb2xvblRlc3QsICcnKVxuICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdC5pbmRleE9mKCdqYXZhc2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZigndmJzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmFzZSAmJiAhb3JpZ2luSW5kZXBlbmRlbnRVcmwudGVzdChocmVmKSkge1xuICAgICAgICBocmVmID0gcmVzb2x2ZVVybChiYXNlLCBocmVmKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaHJlZiA9IGVuY29kZVVSSShocmVmKS5yZXBsYWNlKC8lMjUvZywgJyUnKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBocmVmO1xufVxuY29uc3QgYmFzZVVybHMgPSB7fTtcbmNvbnN0IGp1c3REb21haW4gPSAvXlteOl0rOlxcLypbXi9dKiQvO1xuY29uc3QgcHJvdG9jb2wgPSAvXihbXjpdKzopW1xcc1xcU10qJC87XG5jb25zdCBkb21haW4gPSAvXihbXjpdKzpcXC8qW14vXSopW1xcc1xcU10qJC87XG5mdW5jdGlvbiByZXNvbHZlVXJsKGJhc2UsIGhyZWYpIHtcbiAgICBpZiAoIWJhc2VVcmxzWycgJyArIGJhc2VdKSB7XG4gICAgICAgIC8vIHdlIGNhbiBpZ25vcmUgZXZlcnl0aGluZyBpbiBiYXNlIGFmdGVyIHRoZSBsYXN0IHNsYXNoIG9mIGl0cyBwYXRoIGNvbXBvbmVudCxcbiAgICAgICAgLy8gYnV0IHdlIG1pZ2h0IG5lZWQgdG8gYWRkIF90aGF0X1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTNcbiAgICAgICAgaWYgKGp1c3REb21haW4udGVzdChiYXNlKSkge1xuICAgICAgICAgICAgYmFzZVVybHNbJyAnICsgYmFzZV0gPSBiYXNlICsgJy8nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmFzZVVybHNbJyAnICsgYmFzZV0gPSBydHJpbShiYXNlLCAnLycsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJhc2UgPSBiYXNlVXJsc1snICcgKyBiYXNlXTtcbiAgICBjb25zdCByZWxhdGl2ZUJhc2UgPSBiYXNlLmluZGV4T2YoJzonKSA9PT0gLTE7XG4gICAgaWYgKGhyZWYuc3Vic3RyaW5nKDAsIDIpID09PSAnLy8nKSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZUJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBocmVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UocHJvdG9jb2wsICckMScpICsgaHJlZjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaHJlZi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaHJlZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKGRvbWFpbiwgJyQxJykgKyBocmVmO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJhc2UgKyBocmVmO1xuICAgIH1cbn1cbmNvbnN0IG5vb3BUZXN0ID0geyBleGVjOiAoKSA9PiBudWxsIH07XG5mdW5jdGlvbiBzcGxpdENlbGxzKHRhYmxlUm93LCBjb3VudCkge1xuICAgIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IGNlbGwtZGVsaW1pdGluZyBwaXBlIGhhcyBhIHNwYWNlXG4gICAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gICAgY29uc3Qgcm93ID0gdGFibGVSb3cucmVwbGFjZSgvXFx8L2csIChtYXRjaCwgb2Zmc2V0LCBzdHIpID0+IHtcbiAgICAgICAgbGV0IGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGN1cnIgPSBvZmZzZXQ7XG4gICAgICAgIHdoaWxlICgtLWN1cnIgPj0gMCAmJiBzdHJbY3Vycl0gPT09ICdcXFxcJylcbiAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgICAgIC8vIG9kZCBudW1iZXIgb2Ygc2xhc2hlcyBtZWFucyB8IGlzIGVzY2FwZWRcbiAgICAgICAgICAgIC8vIHNvIHdlIGxlYXZlIGl0IGFsb25lXG4gICAgICAgICAgICByZXR1cm4gJ3wnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkIHNwYWNlIGJlZm9yZSB1bmVzY2FwZWQgfFxuICAgICAgICAgICAgcmV0dXJuICcgfCc7XG4gICAgICAgIH1cbiAgICB9KSwgY2VsbHMgPSByb3cuc3BsaXQoLyBcXHwvKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gRmlyc3QvbGFzdCBjZWxsIGluIGEgcm93IGNhbm5vdCBiZSBlbXB0eSBpZiBpdCBoYXMgbm8gbGVhZGluZy90cmFpbGluZyBwaXBlXG4gICAgaWYgKCFjZWxsc1swXS50cmltKCkpIHtcbiAgICAgICAgY2VsbHMuc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKGNlbGxzLmxlbmd0aCA+IDAgJiYgIWNlbGxzW2NlbGxzLmxlbmd0aCAtIDFdLnRyaW0oKSkge1xuICAgICAgICBjZWxscy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAgIGlmIChjZWxscy5sZW5ndGggPiBjb3VudCkge1xuICAgICAgICAgICAgY2VsbHMuc3BsaWNlKGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChjZWxscy5sZW5ndGggPCBjb3VudClcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBpcyBpZ25vcmVkIHBlciB0aGUgZ2ZtIHNwZWNcbiAgICAgICAgY2VsbHNbaV0gPSBjZWxsc1tpXS50cmltKCkucmVwbGFjZSgvXFxcXFxcfC9nLCAnfCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbHM7XG59XG4vKipcbiAqIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gKiAvYyokLyBpcyB2dWxuZXJhYmxlIHRvIFJFRE9TLlxuICpcbiAqIEBwYXJhbSBzdHJcbiAqIEBwYXJhbSBjXG4gKiBAcGFyYW0gaW52ZXJ0IFJlbW92ZSBzdWZmaXggb2Ygbm9uLWMgY2hhcnMgaW5zdGVhZC4gRGVmYXVsdCBmYWxzZXkuXG4gKi9cbmZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gICAgY29uc3QgbCA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBMZW5ndGggb2Ygc3VmZml4IG1hdGNoaW5nIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICAgIGxldCBzdWZmTGVuID0gMDtcbiAgICAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgICB3aGlsZSAoc3VmZkxlbiA8IGwpIHtcbiAgICAgICAgY29uc3QgY3VyckNoYXIgPSBzdHIuY2hhckF0KGwgLSBzdWZmTGVuIC0gMSk7XG4gICAgICAgIGlmIChjdXJyQ2hhciA9PT0gYyAmJiAhaW52ZXJ0KSB7XG4gICAgICAgICAgICBzdWZmTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyckNoYXIgIT09IGMgJiYgaW52ZXJ0KSB7XG4gICAgICAgICAgICBzdWZmTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIGwgLSBzdWZmTGVuKTtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChzdHIsIGIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoYlsxXSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgbGV0IGxldmVsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RyW2ldID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJbaV0gPT09IGJbMF0pIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyW2ldID09PSBiWzFdKSB7XG4gICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRpb25zKG9wdCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdCB8fCBvcHQuc2lsZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IGNhbGxiYWNrIGlzIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjAuMCwgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gUmVhZCBtb3JlIGhlcmU6IGh0dHBzOi8vbWFya2VkLmpzLm9yZy91c2luZ19wcm8jYXN5bmMnKTtcbiAgICB9XG4gICAgaWYgKG9wdC5zYW5pdGl6ZSB8fCBvcHQuc2FuaXRpemVyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IHNhbml0aXplIGFuZCBzYW5pdGl6ZXIgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDAuNy4wLCBzaG91bGQgbm90IGJlIHVzZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9tYXJrZWQuanMub3JnLyMvVVNJTkdfQURWQU5DRUQubWQjb3B0aW9ucycpO1xuICAgIH1cbiAgICBpZiAob3B0LmhpZ2hsaWdodCB8fCBvcHQubGFuZ1ByZWZpeCAhPT0gJ2xhbmd1YWdlLScpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogaGlnaGxpZ2h0IGFuZCBsYW5nUHJlZml4IHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjAuMCwgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gSW5zdGVhZCB1c2UgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2VkLWhpZ2hsaWdodC4nKTtcbiAgICB9XG4gICAgaWYgKG9wdC5tYW5nbGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogbWFuZ2xlIHBhcmFtZXRlciBpcyBlbmFibGVkIGJ5IGRlZmF1bHQsIGJ1dCBpcyBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNS4wLjAsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gVG8gY2xlYXIgdGhpcyB3YXJuaW5nLCBpbnN0YWxsIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21hcmtlZC1tYW5nbGUsIG9yIGRpc2FibGUgYnkgc2V0dGluZyBge21hbmdsZTogZmFsc2V9YC4nKTtcbiAgICB9XG4gICAgaWYgKG9wdC5iYXNlVXJsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IGJhc2VVcmwgcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjAuMCwgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gSW5zdGVhZCB1c2UgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2VkLWJhc2UtdXJsLicpO1xuICAgIH1cbiAgICBpZiAob3B0LnNtYXJ0eXBhbnRzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IHNtYXJ0eXBhbnRzIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNS4wLjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIEluc3RlYWQgdXNlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21hcmtlZC1zbWFydHlwYW50cy4nKTtcbiAgICB9XG4gICAgaWYgKG9wdC54aHRtbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiB4aHRtbCBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDUuMC4wLCBzaG91bGQgbm90IGJlIHVzZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBJbnN0ZWFkIHVzZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tYXJrZWQteGh0bWwuJyk7XG4gICAgfVxuICAgIGlmIChvcHQuaGVhZGVySWRzIHx8IG9wdC5oZWFkZXJQcmVmaXgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogaGVhZGVySWRzIGFuZCBoZWFkZXJQcmVmaXggcGFyYW1ldGVycyBlbmFibGVkIGJ5IGRlZmF1bHQsIGJ1dCBhcmUgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDUuMC4wLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFRvIGNsZWFyIHRoaXMgd2FybmluZywgaW5zdGFsbCAgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2VkLWdmbS1oZWFkaW5nLWlkLCBvciBkaXNhYmxlIGJ5IHNldHRpbmcgYHtoZWFkZXJJZHM6IGZhbHNlfWAuJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvdXRwdXRMaW5rKGNhcCwgbGluaywgcmF3LCBsZXhlcikge1xuICAgIGNvbnN0IGhyZWYgPSBsaW5rLmhyZWY7XG4gICAgY29uc3QgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgICBjb25zdCB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UoL1xcXFwoW1xcW1xcXV0pL2csICckMScpO1xuICAgIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICByYXcsXG4gICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgdG9rZW5zOiBsZXhlci5pbmxpbmVUb2tlbnModGV4dClcbiAgICAgICAgfTtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3LFxuICAgICAgICBocmVmLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgdGV4dDogZXNjYXBlKHRleHQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0KSB7XG4gICAgY29uc3QgbWF0Y2hJbmRlbnRUb0NvZGUgPSByYXcubWF0Y2goL14oXFxzKykoPzpgYGApLyk7XG4gICAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRUb0NvZGUgPSBtYXRjaEluZGVudFRvQ29kZVsxXTtcbiAgICByZXR1cm4gdGV4dFxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoSW5kZW50SW5Ob2RlID0gbm9kZS5tYXRjaCgvXlxccysvKTtcbiAgICAgICAgaWYgKG1hdGNoSW5kZW50SW5Ob2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaW5kZW50SW5Ob2RlXSA9IG1hdGNoSW5kZW50SW5Ob2RlO1xuICAgICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zbGljZShpbmRlbnRUb0NvZGUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vKipcbiAqIFRva2VuaXplclxuICovXG5jbGFzcyBfVG9rZW5pemVyIHtcbiAgICBvcHRpb25zO1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIHJ1bGVzIHR5cGVcbiAgICBydWxlcztcbiAgICBsZXhlcjtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgIH1cbiAgICBzcGFjZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCAmJiBjYXBbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3BhY2UnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suY29kZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgY29kZUJsb2NrU3R5bGU6ICdpbmRlbnRlZCcsXG4gICAgICAgICAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgICAgICAgICA/IHJ0cmltKHRleHQsICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICA6IHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmVuY2VzKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmZlbmNlcy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHJhdyA9IGNhcFswXTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgY2FwWzNdIHx8ICcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICBsYW5nOiBjYXBbMl0gPyBjYXBbMl0udHJpbSgpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogY2FwWzJdLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICBpZiAoLyMkLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHJ0cmltKHRleHQsICcjJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0cmltbWVkIHx8IC8gJC8udGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21tb25NYXJrIHJlcXVpcmVzIHNwYWNlIGJlZm9yZSB0cmFpbGluZyAjc1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhyKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhyLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHInLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGJsb2NrcXVvdGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suYmxvY2txdW90ZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPlsgXFx0XT8vZ20sICcnKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMubGV4ZXIuc3RhdGUudG9wO1xuICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5sZXhlci5ibG9ja1Rva2Vucyh0ZXh0KTtcbiAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2txdW90ZScsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGlzdChzcmMpIHtcbiAgICAgICAgbGV0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGlzdC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCBidWxsID0gY2FwWzFdLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGlzb3JkZXJlZCA9IGJ1bGwubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICAgICAgICAgIHJhdzogJycsXG4gICAgICAgICAgICAgICAgb3JkZXJlZDogaXNvcmRlcmVkLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiAnJyxcbiAgICAgICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnVsbCA9IGlzb3JkZXJlZCA/IGBcXFxcZHsxLDl9XFxcXCR7YnVsbC5zbGljZSgtMSl9YCA6IGBcXFxcJHtidWxsfWA7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgYnVsbCA9IGlzb3JkZXJlZCA/IGJ1bGwgOiAnWyorLV0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IG5leHQgbGlzdCBpdGVtXG4gICAgICAgICAgICBjb25zdCBpdGVtUmVnZXggPSBuZXcgUmVnRXhwKGBeKCB7MCwzfSR7YnVsbH0pKCg/OltcXHQgXVteXFxcXG5dKik/KD86XFxcXG58JCkpYCk7XG4gICAgICAgICAgICBsZXQgcmF3ID0gJyc7XG4gICAgICAgICAgICBsZXQgaXRlbUNvbnRlbnRzID0gJyc7XG4gICAgICAgICAgICBsZXQgZW5kc1dpdGhCbGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgYnVsbGV0IHBvaW50IGNhbiBzdGFydCBhIG5ldyBMaXN0IEl0ZW1cbiAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kRWFybHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIShjYXAgPSBpdGVtUmVnZXguZXhlYyhzcmMpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucnVsZXMuYmxvY2suaHIudGVzdChzcmMpKSB7IC8vIEVuZCBsaXN0IGlmIGJ1bGxldCB3YXMgYWN0dWFsbHkgSFIgKHBvc3NpYmx5IG1vdmUgaW50byBpdGVtUmVnZXg/KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmF3ID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBjYXBbMl0uc3BsaXQoJ1xcbicsIDEpWzBdLnJlcGxhY2UoL15cXHQrLywgKHQpID0+ICcgJy5yZXBlYXQoMyAqIHQubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmUudHJpbUxlZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IGNhcFsyXS5zZWFyY2goL1teIF0vKTsgLy8gRmluZCBmaXJzdCBub24tc3BhY2UgY2hhclxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSBpbmRlbnQgPiA0ID8gMSA6IGluZGVudDsgLy8gVHJlYXQgaW5kZW50ZWQgY29kZSBibG9ja3MgKD4gNCBzcGFjZXMpIGFzIGhhdmluZyBvbmx5IDEgaW5kZW50XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IGNhcFsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBibGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmUgJiYgL14gKiQvLnRlc3QobmV4dExpbmUpKSB7IC8vIEl0ZW1zIGJlZ2luIHdpdGggYXQgbW9zdCBvbmUgYmxhbmsgbGluZVxuICAgICAgICAgICAgICAgICAgICByYXcgKz0gbmV4dExpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhuZXh0TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kRWFybHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVuZEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRCdWxsZXRSZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19KD86WyorLV18XFxcXGR7MSw5fVsuKV0pKCg/OlsgXFx0XVteXFxcXG5dKik/KD86XFxcXG58JCkpYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhyUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlbmNlc0JlZ2luUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlxcYFxcYFxcYHx+fn4pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdCZWdpblJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0jYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvbGxvd2luZyBsaW5lcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gTGlzdCBJdGVtXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0xpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSByYXdMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gbmV4dExpbmUucmVwbGFjZSgvXiB7MSw0fSg/PSggezR9KSpbXiBdKS9nLCAnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgY29kZSBmZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBoZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGluZ0JlZ2luUmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgc3RhcnQgb2YgbmV3IGJ1bGxldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRCdWxsZXRSZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBydWxlIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KHNyYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TGluZS5zZWFyY2goL1teIF0vKSA+PSBpbmRlbnQgfHwgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBEZWRlbnQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgKz0gJ1xcbicgKyBuZXh0TGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmFncmFwaCBjb250aW51YXRpb24gdW5sZXNzIGxhc3QgbGluZSB3YXMgYSBkaWZmZXJlbnQgYmxvY2sgbGV2ZWwgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnNlYXJjaCgvW14gXS8pID49IDQpIHsgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlbmNlc0JlZ2luUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibGFua0xpbmUgJiYgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBDaGVjayBpZiBjdXJyZW50IGxpbmUgaXMgYmxhbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3ICs9IHJhd0xpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBuZXh0TGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbGlzdC5sb29zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgaXRlbSBlbmRlZCB3aXRoIGEgYmxhbmsgbGluZSwgdGhlIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXFxuICpcXG4gKiQvLnRlc3QocmF3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpc3Rhc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBpc2NoZWNrZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzY2hlY2tlZCA9IGlzdGFza1swXSAhPT0gJ1sgXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gaXRlbUNvbnRlbnRzLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW0nLFxuICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgIHRhc2s6ICEhaXN0YXNrLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaXRlbUNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGlzdC5yYXcgKz0gcmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IGNvbnN1bWUgbmV3bGluZXMgYXQgZW5kIG9mIGZpbmFsIGl0ZW0uIEFsdGVybmF0aXZlbHksIG1ha2UgaXRlbVJlZ2V4ICpzdGFydCogd2l0aCBhbnkgbmV3bGluZXMgdG8gc2ltcGxpZnkvc3BlZWQgdXAgZW5kc1dpdGhCbGFua0xpbmUgbG9naWNcbiAgICAgICAgICAgIGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS5yYXcgPSByYXcudHJpbVJpZ2h0KCk7XG4gICAgICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0udGV4dCA9IGl0ZW1Db250ZW50cy50cmltUmlnaHQoKTtcbiAgICAgICAgICAgIGxpc3QucmF3ID0gbGlzdC5yYXcudHJpbVJpZ2h0KCk7XG4gICAgICAgICAgICAvLyBJdGVtIGNoaWxkIHRva2VucyBoYW5kbGVkIGhlcmUgYXQgZW5kIGJlY2F1c2Ugd2UgbmVlZGVkIHRvIGhhdmUgdGhlIGZpbmFsIGl0ZW0gdG8gdHJpbSBpdCBmaXJzdFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsaXN0Lml0ZW1zW2ldLnRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnMobGlzdC5pdGVtc1tpXS50ZXh0LCBbXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGxpc3Qgc2hvdWxkIGJlIGxvb3NlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYWNlcnMgPSBsaXN0Lml0ZW1zW2ldLnRva2Vucy5maWx0ZXIodCA9PiB0LnR5cGUgPT09ICdzcGFjZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNNdWx0aXBsZUxpbmVCcmVha3MgPSBzcGFjZXJzLmxlbmd0aCA+IDAgJiYgc3BhY2Vycy5zb21lKHQgPT4gL1xcbi4qXFxuLy50ZXN0KHQucmF3KSk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QubG9vc2UgPSBoYXNNdWx0aXBsZUxpbmVCcmVha3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IGFsbCBpdGVtcyB0byBsb29zZSBpZiBsaXN0IGlzIGxvb3NlXG4gICAgICAgICAgICBpZiAobGlzdC5sb29zZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lml0ZW1zW2ldLmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBodG1sKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmh0bWwuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgICAgICAgICAgICAmJiAoY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyksXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogZXNjYXBlKGNhcFswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gdG9rZW47XG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoLnR5cGUgPSAncGFyYWdyYXBoJztcbiAgICAgICAgICAgICAgICBwYXJhZ3JhcGgudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoLnRva2VucyA9IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlZihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjYXBbMV0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gY2FwWzJdID8gY2FwWzJdLnJlcGxhY2UoL148KC4qKT4kLywgJyQxJykucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnN1YnN0cmluZygxLCBjYXBbM10ubGVuZ3RoIC0gMSkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiBjYXBbM107XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkZWYnLFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhYmxlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRhYmxlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGhlYWRlcjogc3BsaXRDZWxscyhjYXBbMV0pLm1hcChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogYywgdG9rZW5zOiBbXSB9O1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgICAgICAgICByb3dzOiBjYXBbM10gJiYgY2FwWzNdLnRyaW0oKSA/IGNhcFszXS5yZXBsYWNlKC9cXG5bIFxcdF0qJC8sICcnKS5zcGxpdCgnXFxuJykgOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpdGVtLmhlYWRlci5sZW5ndGggPT09IGl0ZW0uYWxpZ24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGwgPSBpdGVtLmFsaWduLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgaSwgaiwgaywgcm93O1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxpZ24gPSBpdGVtLmFsaWduW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbCA9IGl0ZW0ucm93cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnJvd3NbaV0gPSBzcGxpdENlbGxzKGl0ZW0ucm93c1tpXSwgaXRlbS5oZWFkZXIubGVuZ3RoKS5tYXAoYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBjLCB0b2tlbnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwYXJzZSBjaGlsZCB0b2tlbnMgaW5zaWRlIGhlYWRlcnMgYW5kIGNlbGxzXG4gICAgICAgICAgICAgICAgLy8gaGVhZGVyIGNoaWxkIHRva2Vuc1xuICAgICAgICAgICAgICAgIGwgPSBpdGVtLmhlYWRlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmhlYWRlcltqXS50b2tlbnMgPSB0aGlzLmxleGVyLmlubGluZShpdGVtLmhlYWRlcltqXS50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2VsbCBjaGlsZCB0b2tlbnNcbiAgICAgICAgICAgICAgICBsID0gaXRlbS5yb3dzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGl0ZW0ucm93c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93W2tdLnRva2VucyA9IHRoaXMubGV4ZXIuaW5saW5lKHJvd1trXS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saGVhZGluZy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGRlcHRoOiBjYXBbMl0uY2hhckF0KDApID09PSAnPScgPyAxIDogMixcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMV0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjYXBbMV0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmFncmFwaChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5wYXJhZ3JhcGguZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgICAgICAgICAgPyBjYXBbMV0uc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgOiBjYXBbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZSh0ZXh0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0ZXh0KHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRleHQuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjYXBbMF0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVzY2FwZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZXNjYXBlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXNjYXBlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBlc2NhcGUoY2FwWzFdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YWcoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRhZy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgJiYgL148YSAvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiAvXjxcXC9hPi9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgICAgICAgICAgICA/ICd0ZXh0J1xuICAgICAgICAgICAgICAgICAgICA6ICdodG1sJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBpbkxpbms6IHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rLFxuICAgICAgICAgICAgICAgIGluUmF3QmxvY2s6IHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayxcbiAgICAgICAgICAgICAgICBibG9jazogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgICAgICAgICAgICAgID8gKHRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGVzY2FwZShjYXBbMF0pKVxuICAgICAgICAgICAgICAgICAgICA6IGNhcFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW5rKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAvXjwvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21tb25tYXJrIHJlcXVpcmVzIG1hdGNoaW5nIGFuZ2xlIGJyYWNrZXRzXG4gICAgICAgICAgICAgICAgaWYgKCEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuZGluZyBhbmdsZSBicmFja2V0IGNhbm5vdCBiZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgY29uc3QgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuICAgICAgICAgICAgICAgIGlmICgodHJpbW1lZFVybC5sZW5ndGggLSBydHJpbVNsYXNoLmxlbmd0aCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhyZWYgPSBjYXBbMl07XG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBsaW5rWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHJlZiA9IGhyZWYudHJpbSgpO1xuICAgICAgICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgISgvPiQvLnRlc3QodHJpbW1lZFVybCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBlZGFudGljIGFsbG93cyBzdGFydGluZyBhbmdsZSBicmFja2V0IHdpdGhvdXQgZW5kaW5nIGFuZ2xlIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgICAgICAgICAgaHJlZjogaHJlZiA/IGhyZWYucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiBocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogdGl0bGVcbiAgICAgICAgICAgIH0sIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmbGluayhzcmMsIGxpbmtzKSB7XG4gICAgICAgIGxldCBjYXA7XG4gICAgICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgICAgICAgIGxldCBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgICAgIGxpbmsgPSBsaW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCBsaW5rLCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtU3Ryb25nKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhciA9ICcnKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLmxEZWxpbS5leGVjKHNyYyk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuICAgICAgICBpZiAobWF0Y2hbM10gJiYgcHJldkNoYXIubWF0Y2goL1tcXHB7TH1cXHB7Tn1dL3UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXh0Q2hhciA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8ICcnO1xuICAgICAgICBpZiAoIW5leHRDaGFyIHx8ICFwcmV2Q2hhciB8fCB0aGlzLnJ1bGVzLmlubGluZS5wdW5jdHVhdGlvbi5leGVjKHByZXZDaGFyKSkge1xuICAgICAgICAgICAgLy8gdW5pY29kZSBSZWdleCBjb3VudHMgZW1vamkgYXMgMSBjaGFyOyBzcHJlYWQgaW50byBhcnJheSBmb3IgcHJvcGVyIGNvdW50ICh1c2VkIG11bHRpcGxlIHRpbWVzIGJlbG93KVxuICAgICAgICAgICAgY29uc3QgbExlbmd0aCA9IFsuLi5tYXRjaFswXV0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCByRGVsaW0sIHJMZW5ndGgsIGRlbGltVG90YWwgPSBsTGVuZ3RoLCBtaWREZWxpbVRvdGFsID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZFJlZyA9IG1hdGNoWzBdWzBdID09PSAnKicgPyB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QgOiB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5yRGVsaW1VbmQ7XG4gICAgICAgICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIENsaXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgtMSAqIHNyYy5sZW5ndGggKyBsTGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBlbmRSZWcuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgckRlbGltID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgbWF0Y2hbNl07XG4gICAgICAgICAgICAgICAgaWYgKCFyRGVsaW0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHNpbmdsZSAqIGluIF9fYWJjKmFiY19fXG4gICAgICAgICAgICAgICAgckxlbmd0aCA9IFsuLi5yRGVsaW1dLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbM10gfHwgbWF0Y2hbNF0pIHsgLy8gZm91bmQgYW5vdGhlciBMZWZ0IERlbGltXG4gICAgICAgICAgICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzVdIHx8IG1hdGNoWzZdKSB7IC8vIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltXG4gICAgICAgICAgICAgICAgICAgIGlmIChsTGVuZ3RoICUgMyAmJiAhKChsTGVuZ3RoICsgckxlbmd0aCkgJSAzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIENvbW1vbk1hcmsgRW1waGFzaXMgUnVsZXMgOS0xMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGltVG90YWwgLT0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZGVsaW1Ub3RhbCA+IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBIYXZlbid0IGZvdW5kIGVub3VnaCBjbG9zaW5nIGRlbGltaXRlcnNcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXh0cmEgY2hhcmFjdGVycy4gKmEqKiogLT4gKmEqXG4gICAgICAgICAgICAgICAgckxlbmd0aCA9IE1hdGgubWluKHJMZW5ndGgsIHJMZW5ndGggKyBkZWxpbVRvdGFsICsgbWlkRGVsaW1Ub3RhbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3ID0gWy4uLnNyY10uc2xpY2UoMCwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgckxlbmd0aCArIDEpLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBgZW1gIGlmIHNtYWxsZXN0IGRlbGltaXRlciBoYXMgb2RkIGNoYXIgY291bnQuICphKioqXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgubWluKGxMZW5ndGgsIHJMZW5ndGgpICUgMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gcmF3LnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2Vucyh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgJ3N0cm9uZycgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBldmVuIGNoYXIgY291bnQuICoqYSoqKlxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSByYXcuc2xpY2UoMiwgLTIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGVzcGFuKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0ucmVwbGFjZSgvXFxuL2csICcgJyk7XG4gICAgICAgICAgICBjb25zdCBoYXNOb25TcGFjZUNoYXJzID0gL1teIF0vLnRlc3QodGV4dCk7XG4gICAgICAgICAgICBjb25zdCBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyA9IC9eIC8udGVzdCh0ZXh0KSAmJiAvICQvLnRlc3QodGV4dCk7XG4gICAgICAgICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSh0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGVzcGFuJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGJyKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ici5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2JyJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWwoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmRlbC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzJdLFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMoY2FwWzJdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdXRvbGluayhzcmMsIG1hbmdsZSkge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0LCBocmVmO1xuICAgICAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFsxXSkgOiBjYXBbMV0pO1xuICAgICAgICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHRva2VuczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybChzcmMsIG1hbmdsZSkge1xuICAgICAgICBsZXQgY2FwO1xuICAgICAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgICAgICAgbGV0IHRleHQsIGhyZWY7XG4gICAgICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKHRoaXMub3B0aW9ucy5tYW5nbGUgPyBtYW5nbGUoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICAgICAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBleHRlbmRlZCBhdXRvbGluayBwYXRoIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICBsZXQgcHJldkNhcFplcm87XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Q2FwWmVybyA9IGNhcFswXTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5pbmxpbmUuX2JhY2twZWRhbC5leGVjKGNhcFswXSlbMF07XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMF0pO1xuICAgICAgICAgICAgICAgIGlmIChjYXBbMV0gPT09ICd3d3cuJykge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgY2FwWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGNhcFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5saW5lVGV4dChzcmMsIHNtYXJ0eXBhbnRzKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRleHQuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgIGlmICh0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2spIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5vcHRpb25zLnNhbml0aXplID8gKHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSkgOiBlc2NhcGUoY2FwWzBdKSkgOiBjYXBbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKHRoaXMub3B0aW9ucy5zbWFydHlwYW50cyA/IHNtYXJ0eXBhbnRzKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gKi9cbi8vIE5vdCBhbGwgcnVsZXMgYXJlIGRlZmluZWQgaW4gdGhlIG9iamVjdCBsaXRlcmFsXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5jb25zdCBibG9jayA9IHtcbiAgICBuZXdsaW5lOiAvXig/OiAqKD86XFxufCQpKSsvLFxuICAgIGNvZGU6IC9eKCB7NH1bXlxcbl0rKD86XFxuKD86ICooPzpcXG58JCkpKik/KSsvLFxuICAgIGZlbmNlczogL14gezAsM30oYHszLH0oPz1bXmBcXG5dKig/OlxcbnwkKSl8fnszLH0pKFteXFxuXSopKD86XFxufCQpKD86fChbXFxzXFxTXSo/KSg/OlxcbnwkKSkoPzogezAsM31cXDFbfmBdKiAqKD89XFxufCQpfCQpLyxcbiAgICBocjogL14gezAsM30oKD86LVtcXHQgXSopezMsfXwoPzpfWyBcXHRdKil7Myx9fCg/OlxcKlsgXFx0XSopezMsfSkoPzpcXG4rfCQpLyxcbiAgICBoZWFkaW5nOiAvXiB7MCwzfSgjezEsNn0pKD89XFxzfCQpKC4qKSg/Olxcbit8JCkvLFxuICAgIGJsb2NrcXVvdGU6IC9eKCB7MCwzfT4gPyhwYXJhZ3JhcGh8W15cXG5dKikoPzpcXG58JCkpKy8sXG4gICAgbGlzdDogL14oIHswLDN9YnVsbCkoWyBcXHRdW15cXG5dKz8pPyg/OlxcbnwkKS8sXG4gICAgaHRtbDogJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgICAgICsgJzwoc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbXFxcXHM+XVtcXFxcc1xcXFxTXSo/KD86PC9cXFxcMT5bXlxcXFxuXSpcXFxcbit8JCknIC8vICgxKVxuICAgICAgICArICd8Y29tbWVudFteXFxcXG5dKihcXFxcbit8JCknIC8vICgyKVxuICAgICAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICAgICArICd8PCFbQS1aXVtcXFxcc1xcXFxTXSo/KD86PlxcXFxuKnwkKScgLy8gKDQpXG4gICAgICAgICsgJ3w8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/KD86XFxcXF1cXFxcXT5cXFxcbip8JCknIC8vICg1KVxuICAgICAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDYpXG4gICAgICAgICsgJ3w8KD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSkoW2Etel1bXFxcXHctXSopKD86YXR0cmlidXRlKSo/ICovPz4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuICopK1xcXFxufCQpJyAvLyAoNykgb3BlbiB0YWdcbiAgICAgICAgKyAnfDwvKD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbYS16XVtcXFxcdy1dKlxcXFxzKj4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuICopK1xcXFxufCQpJyAvLyAoNykgY2xvc2luZyB0YWdcbiAgICAgICAgKyAnKScsXG4gICAgZGVmOiAvXiB7MCwzfVxcWyhsYWJlbClcXF06ICooPzpcXG4gKik/KFtePFxcc11bXlxcc10qfDwuKj8+KSg/Oig/OiArKD86XFxuICopP3wgKlxcbiAqKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8sXG4gICAgdGFibGU6IG5vb3BUZXN0LFxuICAgIGxoZWFkaW5nOiAvXigoPzooPyFeYnVsbCApLnxcXG4oPyFcXG58YnVsbCApKSs/KVxcbiB7MCwzfSg9K3wtKykgKig/Olxcbit8JCkvLFxuICAgIC8vIHJlZ2V4IHRlbXBsYXRlLCBwbGFjZWhvbGRlcnMgd2lsbCBiZSByZXBsYWNlZCBhY2NvcmRpbmcgdG8gZGlmZmVyZW50IHBhcmFncmFwaFxuICAgIC8vIGludGVycnVwdGlvbiBydWxlcyBvZiBjb21tb25tYXJrIGFuZCB0aGUgb3JpZ2luYWwgbWFya2Rvd24gc3BlYzpcbiAgICBfcGFyYWdyYXBoOiAvXihbXlxcbl0rKD86XFxuKD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfGZlbmNlc3xsaXN0fGh0bWx8dGFibGV8ICtcXG4pW15cXG5dKykqKS8sXG4gICAgdGV4dDogL15bXlxcbl0rL1xufTtcbmJsb2NrLl9sYWJlbCA9IC8oPyFcXHMqXFxdKSg/OlxcXFwufFteXFxbXFxdXFxcXF0pKy87XG5ibG9jay5fdGl0bGUgPSAvKD86XCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8J1teJ1xcbl0qKD86XFxuW14nXFxuXSspKlxcbj8nfFxcKFteKCldKlxcKSkvO1xuYmxvY2suZGVmID0gZWRpdChibG9jay5kZWYpXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2suX2xhYmVsKVxuICAgIC5yZXBsYWNlKCd0aXRsZScsIGJsb2NrLl90aXRsZSlcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGR7MSw5fVsuKV0pLztcbmJsb2NrLmxpc3RJdGVtU3RhcnQgPSBlZGl0KC9eKCAqKShidWxsKSAqLylcbiAgICAucmVwbGFjZSgnYnVsbCcsIGJsb2NrLmJ1bGxldClcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLmxpc3QgPSBlZGl0KGJsb2NrLmxpc3QpXG4gICAgLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAgIC5yZXBsYWNlKCdocicsICdcXFxcbisoPz1cXFxcMT8oPzooPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpKScpXG4gICAgLnJlcGxhY2UoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJylcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLl90YWcgPSAnYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJhc2V8YmFzZWZvbnR8YmxvY2txdW90ZXxib2R5fGNhcHRpb24nXG4gICAgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJ1xuICAgICsgJ3xmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aFsxLTZdfGhlYWR8aGVhZGVyfGhyfGh0bWx8aWZyYW1lJ1xuICAgICsgJ3xsZWdlbmR8bGl8bGlua3xtYWlufG1lbnV8bWVudWl0ZW18bWV0YXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9uJ1xuICAgICsgJ3xwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHInXG4gICAgKyAnfHRyYWNrfHVsJztcbmJsb2NrLl9jb21tZW50ID0gLzwhLS0oPyEtPz4pW1xcc1xcU10qPyg/Oi0tPnwkKS87XG5ibG9jay5odG1sID0gZWRpdChibG9jay5odG1sLCAnaScpXG4gICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jay5fY29tbWVudClcbiAgICAucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZylcbiAgICAucmVwbGFjZSgnYXR0cmlidXRlJywgLyArW2EtekEtWjpfXVtcXHcuOi1dKig/OiAqPSAqXCJbXlwiXFxuXSpcInwgKj0gKidbXidcXG5dKid8ICo9ICpbXlxcc1wiJz08PmBdKyk/LylcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLmxoZWFkaW5nID0gZWRpdChibG9jay5saGVhZGluZylcbiAgICAucmVwbGFjZSgvYnVsbC9nLCBibG9jay5idWxsZXQpIC8vIGxpc3RzIGNhbiBpbnRlcnJ1cHRcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLnBhcmFncmFwaCA9IGVkaXQoYmxvY2suX3BhcmFncmFwaClcbiAgICAucmVwbGFjZSgnaHInLCBibG9jay5ocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJylcbiAgICAucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbiAgICAucmVwbGFjZSgnfHRhYmxlJywgJycpXG4gICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gICAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5ibG9ja3F1b3RlID0gZWRpdChibG9jay5ibG9ja3F1b3RlKVxuICAgIC5yZXBsYWNlKCdwYXJhZ3JhcGgnLCBibG9jay5wYXJhZ3JhcGgpXG4gICAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gKi9cbmJsb2NrLm5vcm1hbCA9IHsgLi4uYmxvY2sgfTtcbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuYmxvY2suZ2ZtID0ge1xuICAgIC4uLmJsb2NrLm5vcm1hbCxcbiAgICB0YWJsZTogJ14gKihbXlxcXFxuIF0uKlxcXFx8LiopXFxcXG4nIC8vIEhlYWRlclxuICAgICAgICArICcgezAsM30oPzpcXFxcfCAqKT8oOj8tKzo/ICooPzpcXFxcfCAqOj8tKzo/ICopKikoPzpcXFxcfCAqKT8nIC8vIEFsaWduXG4gICAgICAgICsgJyg/OlxcXFxuKCg/Oig/ISAqXFxcXG58aHJ8aGVhZGluZ3xibG9ja3F1b3RlfGNvZGV8ZmVuY2VzfGxpc3R8aHRtbCkuKig/OlxcXFxufCQpKSopXFxcXG4qfCQpJyAvLyBDZWxsc1xufTtcbmJsb2NrLmdmbS50YWJsZSA9IGVkaXQoYmxvY2suZ2ZtLnRhYmxlKVxuICAgIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSAnKVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCdjb2RlJywgJyB7NH1bXlxcXFxuXScpXG4gICAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gICAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHRhYmxlcyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLmdmbS5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpXG4gICAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpXG4gICAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gICAgLnJlcGxhY2UoJ3RhYmxlJywgYmxvY2suZ2ZtLnRhYmxlKSAvLyBpbnRlcnJ1cHQgcGFyYWdyYXBocyB3aXRoIHRhYmxlXG4gICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gICAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gICAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAqL1xuYmxvY2sucGVkYW50aWMgPSB7XG4gICAgLi4uYmxvY2subm9ybWFsLFxuICAgIGh0bWw6IGVkaXQoJ14gKig/OmNvbW1lbnQgKig/OlxcXFxufFxcXFxzKiQpJ1xuICAgICAgICArICd8PCh0YWcpW1xcXFxzXFxcXFNdKz88L1xcXFwxPiAqKD86XFxcXG57Mix9fFxcXFxzKiQpJyAvLyBjbG9zZWQgdGFnXG4gICAgICAgICsgJ3w8dGFnKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFxcXFxzW15cXCdcIi8+XFxcXHNdKikqPy8/PiAqKD86XFxcXG57Mix9fFxcXFxzKiQpKScpXG4gICAgICAgIC5yZXBsYWNlKCdjb21tZW50JywgYmxvY2suX2NvbW1lbnQpXG4gICAgICAgIC5yZXBsYWNlKC90YWcvZywgJyg/ISg/OidcbiAgICAgICAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGV8dmFyfHNhbXB8a2JkfHN1YidcbiAgICAgICAgKyAnfHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkb3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZyknXG4gICAgICAgICsgJ1xcXFxiKVxcXFx3Kyg/ITp8W15cXFxcd1xcXFxzQF0qQClcXFxcYicpXG4gICAgICAgIC5nZXRSZWdleCgpLFxuICAgIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICsoW1wiKF1bXlxcbl0rW1wiKV0pKT8gKig/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eKCN7MSw2fSkoLiopKD86XFxuK3wkKS8sXG4gICAgZmVuY2VzOiBub29wVGVzdCxcbiAgICBsaGVhZGluZzogL14oLis/KVxcbiB7MCwzfSg9K3wtKykgKig/Olxcbit8JCkvLFxuICAgIHBhcmFncmFwaDogZWRpdChibG9jay5ub3JtYWwuX3BhcmFncmFwaClcbiAgICAgICAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gICAgICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyAqI3sxLDZ9ICpbXlxcbl0nKVxuICAgICAgICAucmVwbGFjZSgnbGhlYWRpbmcnLCBibG9jay5saGVhZGluZylcbiAgICAgICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgICAgIC5yZXBsYWNlKCd8ZmVuY2VzJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCd8bGlzdCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnfGh0bWwnLCAnJylcbiAgICAgICAgLmdldFJlZ2V4KClcbn07XG4vKipcbiAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gKi9cbi8vIE5vdCBhbGwgcnVsZXMgYXJlIGRlZmluZWQgaW4gdGhlIG9iamVjdCBsaXRlcmFsXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5jb25zdCBpbmxpbmUgPSB7XG4gICAgZXNjYXBlOiAvXlxcXFwoWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9fl0pLyxcbiAgICBhdXRvbGluazogL148KHNjaGVtZTpbXlxcc1xceDAwLVxceDFmPD5dKnxlbWFpbCk+LyxcbiAgICB1cmw6IG5vb3BUZXN0LFxuICAgIHRhZzogJ15jb21tZW50J1xuICAgICAgICArICd8XjwvW2EtekEtWl1bXFxcXHc6LV0qXFxcXHMqPicgLy8gc2VsZi1jbG9zaW5nIHRhZ1xuICAgICAgICArICd8XjxbYS16QS1aXVtcXFxcdy1dKig/OmF0dHJpYnV0ZSkqP1xcXFxzKi8/PicgLy8gb3BlbiB0YWdcbiAgICAgICAgKyAnfF48XFxcXD9bXFxcXHNcXFxcU10qP1xcXFw/PicgLy8gcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiwgZS5nLiA8P3BocCA/PlxuICAgICAgICArICd8XjwhW2EtekEtWl0rXFxcXHNbXFxcXHNcXFxcU10qPz4nIC8vIGRlY2xhcmF0aW9uLCBlLmcuIDwhRE9DVFlQRSBodG1sPlxuICAgICAgICArICd8XjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPicsXG4gICAgbGluazogL14hP1xcWyhsYWJlbClcXF1cXChcXHMqKGhyZWYpKD86XFxzKyh0aXRsZSkpP1xccypcXCkvLFxuICAgIHJlZmxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFxbKHJlZilcXF0vLFxuICAgIG5vbGluazogL14hP1xcWyhyZWYpXFxdKD86XFxbXFxdKT8vLFxuICAgIHJlZmxpbmtTZWFyY2g6ICdyZWZsaW5rfG5vbGluayg/IVxcXFwoKScsXG4gICAgZW1TdHJvbmc6IHtcbiAgICAgICAgbERlbGltOiAvXig/OlxcKisoPzooKD8hXFwqKVtwdW5jdF0pfFteXFxzKl0pKXxeXysoPzooKD8hXylbcHVuY3RdKXwoW15cXHNfXSkpLyxcbiAgICAgICAgLy8gICAgICAgICAoMSkgYW5kICgyKSBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlci4gKDMpIGFuZCAoNCkgY2FuIG9ubHkgYmUgTGVmdC4gICg1KSBhbmQgKDYpIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodC5cbiAgICAgICAgLy8gICAgICAgICB8IFNraXAgb3JwaGFuIGluc2lkZSBzdHJvbmcgICAgICB8IENvbnN1bWUgdG8gZGVsaW0gfCAoMSkgIyoqKiAgICAgICAgICAgICAgfCAoMikgYSoqKiMsIGEqKiogICAgICAgICAgICAgICAgICAgIHwgKDMpICMqKiphLCAqKiphICAgICAgICAgICAgICAgICAgfCAoNCkgKioqIyAgICAgICAgICAgICAgICAgfCAoNSkgIyoqKiMgICAgICAgICAgICAgICAgICAgICAgICAgfCAoNikgYSoqKmFcbiAgICAgICAgckRlbGltQXN0OiAvXlteXypdKj9fX1teXypdKj9cXCpbXl8qXSo/KD89X18pfFteKl0rKD89W14qXSl8KD8hXFwqKVtwdW5jdF0oXFwqKykoPz1bXFxzXXwkKXxbXnB1bmN0XFxzXShcXCorKSg/IVxcKikoPz1bcHVuY3RcXHNdfCQpfCg/IVxcKilbcHVuY3RcXHNdKFxcKispKD89W15wdW5jdFxcc10pfFtcXHNdKFxcKispKD8hXFwqKSg/PVtwdW5jdF0pfCg/IVxcKilbcHVuY3RdKFxcKispKD8hXFwqKSg/PVtwdW5jdF0pfFtecHVuY3RcXHNdKFxcKispKD89W15wdW5jdFxcc10pLyxcbiAgICAgICAgckRlbGltVW5kOiAvXlteXypdKj9cXCpcXCpbXl8qXSo/X1teXypdKj8oPz1cXCpcXCopfFteX10rKD89W15fXSl8KD8hXylbcHVuY3RdKF8rKSg/PVtcXHNdfCQpfFtecHVuY3RcXHNdKF8rKSg/IV8pKD89W3B1bmN0XFxzXXwkKXwoPyFfKVtwdW5jdFxcc10oXyspKD89W15wdW5jdFxcc10pfFtcXHNdKF8rKSg/IV8pKD89W3B1bmN0XSl8KD8hXylbcHVuY3RdKF8rKSg/IV8pKD89W3B1bmN0XSkvIC8vIF4tIE5vdCBhbGxvd2VkIGZvciBfXG4gICAgfSxcbiAgICBjb2RlOiAvXihgKykoW15gXXxbXmBdW1xcc1xcU10qP1teYF0pXFwxKD8hYCkvLFxuICAgIGJyOiAvXiggezIsfXxcXFxcKVxcbig/IVxccyokKS8sXG4gICAgZGVsOiBub29wVGVzdCxcbiAgICB0ZXh0OiAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2AqX118XFxiX3wkKXxbXiBdKD89IHsyLH1cXG4pKSkvLFxuICAgIHB1bmN0dWF0aW9uOiAvXigoPyFbKl9dKVtcXHNwdW5jdHVhdGlvbl0pL1xufTtcbi8vIGxpc3Qgb2YgdW5pY29kZSBwdW5jdHVhdGlvbiBtYXJrcywgcGx1cyBhbnkgbWlzc2luZyBjaGFyYWN0ZXJzIGZyb20gQ29tbW9uTWFyayBzcGVjXG5pbmxpbmUuX3B1bmN0dWF0aW9uID0gJ1xcXFxwe1B9JCs8PT5gXnx+JztcbmlubGluZS5wdW5jdHVhdGlvbiA9IGVkaXQoaW5saW5lLnB1bmN0dWF0aW9uLCAndScpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4vLyBzZXF1ZW5jZXMgZW0gc2hvdWxkIHNraXAgb3ZlciBbdGl0bGVdKGxpbmspLCBgY29kZWAsIDxodG1sPlxuaW5saW5lLmJsb2NrU2tpcCA9IC9cXFtbXltcXF1dKj9cXF1cXChbXlxcKFxcKV0qP1xcKXxgW15gXSo/YHw8W148Pl0qPz4vZztcbmlubGluZS5hbnlQdW5jdHVhdGlvbiA9IC9cXFxcW3B1bmN0XS9nO1xuaW5saW5lLl9lc2NhcGVzID0gL1xcXFwoW3B1bmN0XSkvZztcbmlubGluZS5fY29tbWVudCA9IGVkaXQoYmxvY2suX2NvbW1lbnQpLnJlcGxhY2UoJyg/Oi0tPnwkKScsICctLT4nKS5nZXRSZWdleCgpO1xuaW5saW5lLmVtU3Ryb25nLmxEZWxpbSA9IGVkaXQoaW5saW5lLmVtU3Ryb25nLmxEZWxpbSwgJ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLmVtU3Ryb25nLnJEZWxpbUFzdCA9IGVkaXQoaW5saW5lLmVtU3Ryb25nLnJEZWxpbUFzdCwgJ2d1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5lbVN0cm9uZy5yRGVsaW1VbmQgPSBlZGl0KGlubGluZS5lbVN0cm9uZy5yRGVsaW1VbmQsICdndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUuYW55UHVuY3R1YXRpb24gPSBlZGl0KGlubGluZS5hbnlQdW5jdHVhdGlvbiwgJ2d1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5fZXNjYXBlcyA9IGVkaXQoaW5saW5lLl9lc2NhcGVzLCAnZ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLl9zY2hlbWUgPSAvW2EtekEtWl1bYS16QS1aMC05Ky4tXXsxLDMxfS87XG5pbmxpbmUuX2VtYWlsID0gL1thLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rKEApW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSsoPyFbLV9dKS87XG5pbmxpbmUuYXV0b2xpbmsgPSBlZGl0KGlubGluZS5hdXRvbGluaylcbiAgICAucmVwbGFjZSgnc2NoZW1lJywgaW5saW5lLl9zY2hlbWUpXG4gICAgLnJlcGxhY2UoJ2VtYWlsJywgaW5saW5lLl9lbWFpbClcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5fYXR0cmlidXRlID0gL1xccytbYS16QS1aOl9dW1xcdy46LV0qKD86XFxzKj1cXHMqXCJbXlwiXSpcInxcXHMqPVxccyonW14nXSonfFxccyo9XFxzKlteXFxzXCInPTw+YF0rKT8vO1xuaW5saW5lLnRhZyA9IGVkaXQoaW5saW5lLnRhZylcbiAgICAucmVwbGFjZSgnY29tbWVudCcsIGlubGluZS5fY29tbWVudClcbiAgICAucmVwbGFjZSgnYXR0cmlidXRlJywgaW5saW5lLl9hdHRyaWJ1dGUpXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUuX2xhYmVsID0gLyg/OlxcWyg/OlxcXFwufFteXFxbXFxdXFxcXF0pKlxcXXxcXFxcLnxgW15gXSpgfFteXFxbXFxdXFxcXGBdKSo/LztcbmlubGluZS5faHJlZiA9IC88KD86XFxcXC58W15cXG48PlxcXFxdKSs+fFteXFxzXFx4MDAtXFx4MWZdKi87XG5pbmxpbmUuX3RpdGxlID0gL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS87XG5pbmxpbmUubGluayA9IGVkaXQoaW5saW5lLmxpbmspXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgICAucmVwbGFjZSgnaHJlZicsIGlubGluZS5faHJlZilcbiAgICAucmVwbGFjZSgndGl0bGUnLCBpbmxpbmUuX3RpdGxlKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLnJlZmxpbmsgPSBlZGl0KGlubGluZS5yZWZsaW5rKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gICAgLnJlcGxhY2UoJ3JlZicsIGJsb2NrLl9sYWJlbClcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5ub2xpbmsgPSBlZGl0KGlubGluZS5ub2xpbmspXG4gICAgLnJlcGxhY2UoJ3JlZicsIGJsb2NrLl9sYWJlbClcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5yZWZsaW5rU2VhcmNoID0gZWRpdChpbmxpbmUucmVmbGlua1NlYXJjaCwgJ2cnKVxuICAgIC5yZXBsYWNlKCdyZWZsaW5rJywgaW5saW5lLnJlZmxpbmspXG4gICAgLnJlcGxhY2UoJ25vbGluaycsIGlubGluZS5ub2xpbmspXG4gICAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5pbmxpbmUubm9ybWFsID0geyAuLi5pbmxpbmUgfTtcbi8qKlxuICogUGVkYW50aWMgSW5saW5lIEdyYW1tYXJcbiAqL1xuaW5saW5lLnBlZGFudGljID0ge1xuICAgIC4uLmlubGluZS5ub3JtYWwsXG4gICAgc3Ryb25nOiB7XG4gICAgICAgIHN0YXJ0OiAvXl9ffFxcKlxcKi8sXG4gICAgICAgIG1pZGRsZTogL15fXyg/PVxcUykoW1xcc1xcU10qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqXFwqKD8hXFwqKS8sXG4gICAgICAgIGVuZEFzdDogL1xcKlxcKig/IVxcKikvZyxcbiAgICAgICAgZW5kVW5kOiAvX18oPyFfKS9nXG4gICAgfSxcbiAgICBlbToge1xuICAgICAgICBzdGFydDogL15ffFxcKi8sXG4gICAgICAgIG1pZGRsZTogL14oKVxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopfF5fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKS8sXG4gICAgICAgIGVuZEFzdDogL1xcKig/IVxcKikvZyxcbiAgICAgICAgZW5kVW5kOiAvXyg/IV8pL2dcbiAgICB9LFxuICAgIGxpbms6IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXCgoLio/KVxcKS8pXG4gICAgICAgIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gICAgICAgIC5nZXRSZWdleCgpLFxuICAgIHJlZmxpbms6IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXHMqXFxbKFteXFxdXSopXFxdLylcbiAgICAgICAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgICAgICAgLmdldFJlZ2V4KClcbn07XG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5pbmxpbmUuZ2ZtID0ge1xuICAgIC4uLmlubGluZS5ub3JtYWwsXG4gICAgZXNjYXBlOiBlZGl0KGlubGluZS5lc2NhcGUpLnJlcGxhY2UoJ10pJywgJ358XSknKS5nZXRSZWdleCgpLFxuICAgIF9leHRlbmRlZF9lbWFpbDogL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLyxcbiAgICB1cmw6IC9eKCg/OmZ0cHxodHRwcz8pOlxcL1xcL3x3d3dcXC4pKD86W2EtekEtWjAtOVxcLV0rXFwuPykrW15cXHM8XSp8XmVtYWlsLyxcbiAgICBfYmFja3BlZGFsOiAvKD86W14/IS4sOjsqXydcIn4oKSZdK3xcXChbXildKlxcKXwmKD8hW2EtekEtWjAtOV0rOyQpfFs/IS4sOjsqXydcIn4pXSsoPyEkKSkrLyxcbiAgICBkZWw6IC9eKH5+PykoPz1bXlxcc35dKShbXFxzXFxTXSo/W15cXHN+XSlcXDEoPz1bXn5dfCQpLyxcbiAgICB0ZXh0OiAvXihbYH5dK3xbXmB+XSkoPzooPz0gezIsfVxcbil8KD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2Aqfl9dfFxcYl98aHR0cHM/OlxcL1xcL3xmdHA6XFwvXFwvfHd3d1xcLnwkKXxbXiBdKD89IHsyLH1cXG4pfFteYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dKD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKSkpL1xufTtcbmlubGluZS5nZm0udXJsID0gZWRpdChpbmxpbmUuZ2ZtLnVybCwgJ2knKVxuICAgIC5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5nZm0uX2V4dGVuZGVkX2VtYWlsKVxuICAgIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICovXG5pbmxpbmUuYnJlYWtzID0ge1xuICAgIC4uLmlubGluZS5nZm0sXG4gICAgYnI6IGVkaXQoaW5saW5lLmJyKS5yZXBsYWNlKCd7Mix9JywgJyonKS5nZXRSZWdleCgpLFxuICAgIHRleHQ6IGVkaXQoaW5saW5lLmdmbS50ZXh0KVxuICAgICAgICAucmVwbGFjZSgnXFxcXGJfJywgJ1xcXFxiX3wgezIsfVxcXFxuJylcbiAgICAgICAgLnJlcGxhY2UoL1xcezIsXFx9L2csICcqJylcbiAgICAgICAgLmdldFJlZ2V4KClcbn07XG5cbi8qKlxuICogc21hcnR5cGFudHMgdGV4dCByZXBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBzbWFydHlwYW50cyh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHRcbiAgICAgICAgLy8gZW0tZGFzaGVzXG4gICAgICAgIC5yZXBsYWNlKC8tLS0vZywgJ1xcdTIwMTQnKVxuICAgICAgICAvLyBlbi1kYXNoZXNcbiAgICAgICAgLnJlcGxhY2UoLy0tL2csICdcXHUyMDEzJylcbiAgICAgICAgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcIlxcc10pJy9nLCAnJDFcXHUyMDE4JylcbiAgICAgICAgLy8gY2xvc2luZyBzaW5nbGVzICYgYXBvc3Ryb3BoZXNcbiAgICAgICAgLnJlcGxhY2UoLycvZywgJ1xcdTIwMTknKVxuICAgICAgICAvLyBvcGVuaW5nIGRvdWJsZXNcbiAgICAgICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1xcdTIwMThcXHNdKVwiL2csICckMVxcdTIwMWMnKVxuICAgICAgICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csICdcXHUyMDFkJylcbiAgICAgICAgLy8gZWxsaXBzZXNcbiAgICAgICAgLnJlcGxhY2UoL1xcLnszfS9nLCAnXFx1MjAyNicpO1xufVxuLyoqXG4gKiBtYW5nbGUgZW1haWwgYWRkcmVzc2VzXG4gKi9cbmZ1bmN0aW9uIG1hbmdsZSh0ZXh0KSB7XG4gICAgbGV0IG91dCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaCA9IE1hdGgucmFuZG9tKCkgPiAwLjVcbiAgICAgICAgICAgID8gJ3gnICsgdGV4dC5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgOiB0ZXh0LmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoKTtcbiAgICAgICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQmxvY2sgTGV4ZXJcbiAqL1xuY2xhc3MgX0xleGVyIHtcbiAgICB0b2tlbnM7XG4gICAgb3B0aW9ucztcbiAgICBzdGF0ZTtcbiAgICB0b2tlbml6ZXI7XG4gICAgaW5saW5lUXVldWU7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAvLyBUb2tlbkxpc3QgY2Fubm90IGJlIGNyZWF0ZWQgaW4gb25lIGdvXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICAgICAgdGhpcy5vcHRpb25zLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXIgfHwgbmV3IF9Ub2tlbml6ZXIoKTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyO1xuICAgICAgICB0aGlzLnRva2VuaXplci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0aGlzLnRva2VuaXplci5sZXhlciA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGluTGluazogZmFsc2UsXG4gICAgICAgICAgICBpblJhd0Jsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgIHRvcDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBydWxlcyA9IHtcbiAgICAgICAgICAgIGJsb2NrOiBibG9jay5ub3JtYWwsXG4gICAgICAgICAgICBpbmxpbmU6IGlubGluZS5ub3JtYWxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5wZWRhbnRpYztcbiAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5wZWRhbnRpYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICBydWxlcy5ibG9jayA9IGJsb2NrLmdmbTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmJyZWFrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5nZm07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2tlbml6ZXIucnVsZXMgPSBydWxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3NlIFJ1bGVzXG4gICAgICovXG4gICAgc3RhdGljIGdldCBydWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgaW5saW5lXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBMZXggTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIGxleChzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGV4ZXIgPSBuZXcgX0xleGVyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBMZXggSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBsZXhJbmxpbmUoc3JjLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxleGVyID0gbmV3IF9MZXhlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGxleGVyLmlubGluZVRva2VucyhzcmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwcm9jZXNzaW5nXG4gICAgICovXG4gICAgbGV4KHNyYykge1xuICAgICAgICBzcmMgPSBzcmNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKTtcbiAgICAgICAgdGhpcy5ibG9ja1Rva2VucyhzcmMsIHRoaXMudG9rZW5zKTtcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIHdoaWxlIChuZXh0ID0gdGhpcy5pbmxpbmVRdWV1ZS5zaGlmdCgpKSB7XG4gICAgICAgICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgICB9XG4gICAgYmxvY2tUb2tlbnMoc3JjLCB0b2tlbnMgPSBbXSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFx0L2csICcgICAgJykucmVwbGFjZSgvXiArJC9nbSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL14oICopKFxcdCspL2dtLCAoXywgbGVhZGluZywgdGFicykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWFkaW5nICsgJyAgICAnLnJlcGVhdCh0YWJzLmxlbmd0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9rZW47XG4gICAgICAgIGxldCBsYXN0VG9rZW47XG4gICAgICAgIGxldCBjdXRTcmM7XG4gICAgICAgIGxldCBsYXN0UGFyYWdyYXBoQ2xpcHBlZDtcbiAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuYmxvY2tcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9jay5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID0gZXh0VG9rZW5pemVyLmNhbGwoeyBsZXhlcjogdGhpcyB9LCBzcmMsIHRva2VucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5ld2xpbmVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnNwYWNlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5yYXcubGVuZ3RoID09PSAxICYmIHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBzaW5nbGUgXFxuIGFzIGEgc3BhY2VyLCBpdCdzIHRlcm1pbmF0aW5nIHRoZSBsYXN0IGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIG1vdmUgaXQgdGhlcmUgc28gdGhhdCB3ZSBkb24ndCBnZXQgdW5lY2Vzc2FyeSBwYXJhZ3JhcGggdGFnc1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnJhdyArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgLy8gQW4gaW5kZW50ZWQgY29kZSBibG9jayBjYW5ub3QgaW50ZXJydXB0IGEgcGFyYWdyYXBoLlxuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmZW5jZXNcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoZWFkaW5nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhyXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBibG9ja3F1b3RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ibG9ja3F1b3RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxpc3RcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpc3Qoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaHRtbFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHRtbChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWZcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlZihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b2tlbi50aXRsZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRhYmxlIChnZm0pXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaGVhZGluZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGhlYWRpbmcoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgICAgICAgICAgLy8gcHJldmVudCBwYXJhZ3JhcGggY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICAgICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0QmxvY2suZm9yRWFjaCgoZ2V0U3RhcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5wYXJhZ3JhcGgoY3V0U3JjKSkpIHtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyYWdyYXBoQ2xpcHBlZCAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RQYXJhZ3JhcGhDbGlwcGVkID0gKGN1dFNyYy5sZW5ndGggIT09IHNyYy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50ZXh0KHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGlubGluZShzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUucHVzaCh7IHNyYywgdG9rZW5zIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgaW5saW5lVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgbGV0IHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYztcbiAgICAgICAgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcbiAgICAgICAgbGV0IG1hc2tlZFNyYyA9IHNyYztcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBsZXQga2VlcFByZXZDaGFyLCBwcmV2Q2hhcjtcbiAgICAgICAgLy8gTWFzayBvdXQgcmVmbGlua3NcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zLmxpbmtzKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5zLmxpbmtzKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyAnYScucmVwZWF0KG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFzayBvdXQgb3RoZXIgYmxvY2tzXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5sYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hc2sgb3V0IGVzY2FwZWQgY2hhcmFjdGVyc1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICcrKycgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLmxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmVcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmUuc29tZSgoZXh0VG9rZW5pemVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2NhcGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVzY2FwZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGlua1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnJlZmxpbmsoc3JjLCB0aGlzLnRva2Vucy5saW5rcykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbSAmIHN0cm9uZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29kZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZXNwYW4oc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJyKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlbCAoZ2ZtKVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVsKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGF1dG9saW5rXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5hdXRvbGluayhzcmMsIG1hbmdsZSkpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVybCAoZ2ZtKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjLCBtYW5nbGUpKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGV4dFxuICAgICAgICAgICAgLy8gcHJldmVudCBpbmxpbmVUZXh0IGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuICAgICAgICAgICAgY3V0U3JjID0gc3JjO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wU3JjID0gc3JjLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUuZm9yRWFjaCgoZ2V0U3RhcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmlubGluZVRleHQoY3V0U3JjLCBzbWFydHlwYW50cykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5yYXcuc2xpY2UoLTEpICE9PSAnXycpIHsgLy8gVHJhY2sgcHJldkNoYXIgYmVmb3JlIHN0cmluZyBvZiBfX19fIHN0YXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgcHJldkNoYXIgPSB0b2tlbi5yYXcuc2xpY2UoLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZWVwUHJldkNoYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZW5kZXJlclxuICovXG5jbGFzcyBfUmVuZGVyZXIge1xuICAgIG9wdGlvbnM7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICB9XG4gICAgY29kZShjb2RlLCBpbmZvc3RyaW5nLCBlc2NhcGVkKSB7XG4gICAgICAgIGNvbnN0IGxhbmcgPSAoaW5mb3N0cmluZyB8fCAnJykubWF0Y2goL15cXFMqLyk/LlswXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoY29kZSwgbGFuZyk7XG4gICAgICAgICAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29kZSA9IG91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9cXG4kLywgJycpICsgJ1xcbic7XG4gICAgICAgIGlmICghbGFuZykge1xuICAgICAgICAgICAgcmV0dXJuICc8cHJlPjxjb2RlPidcbiAgICAgICAgICAgICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICAgICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInXG4gICAgICAgICAgICArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4XG4gICAgICAgICAgICArIGVzY2FwZShsYW5nKVxuICAgICAgICAgICAgKyAnXCI+J1xuICAgICAgICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICB9XG4gICAgYmxvY2txdW90ZShxdW90ZSkge1xuICAgICAgICByZXR1cm4gYDxibG9ja3F1b3RlPlxcbiR7cXVvdGV9PC9ibG9ja3F1b3RlPlxcbmA7XG4gICAgfVxuICAgIGh0bWwoaHRtbCwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIGhlYWRpbmcodGV4dCwgbGV2ZWwsIHJhdywgc2x1Z2dlcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcklkcykge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLm9wdGlvbnMuaGVhZGVyUHJlZml4ICsgc2x1Z2dlci5zbHVnKHJhdyk7XG4gICAgICAgICAgICByZXR1cm4gYDxoJHtsZXZlbH0gaWQ9XCIke2lkfVwiPiR7dGV4dH08L2gke2xldmVsfT5cXG5gO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlnbm9yZSBJRHNcbiAgICAgICAgcmV0dXJuIGA8aCR7bGV2ZWx9PiR7dGV4dH08L2gke2xldmVsfT5cXG5gO1xuICAgIH1cbiAgICBocigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG4gICAgfVxuICAgIGxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJztcbiAgICAgICAgY29uc3Qgc3RhcnRhdHQgPSAob3JkZXJlZCAmJiBzdGFydCAhPT0gMSkgPyAoJyBzdGFydD1cIicgKyBzdGFydCArICdcIicpIDogJyc7XG4gICAgICAgIHJldHVybiAnPCcgKyB0eXBlICsgc3RhcnRhdHQgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG4gICAgfVxuICAgIGxpc3RpdGVtKHRleHQsIHRhc2ssIGNoZWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIGA8bGk+JHt0ZXh0fTwvbGk+XFxuYDtcbiAgICB9XG4gICAgY2hlY2tib3goY2hlY2tlZCkge1xuICAgICAgICByZXR1cm4gJzxpbnB1dCAnXG4gICAgICAgICAgICArIChjaGVja2VkID8gJ2NoZWNrZWQ9XCJcIiAnIDogJycpXG4gICAgICAgICAgICArICdkaXNhYmxlZD1cIlwiIHR5cGU9XCJjaGVja2JveFwiJ1xuICAgICAgICAgICAgKyAodGhpcy5vcHRpb25zLnhodG1sID8gJyAvJyA6ICcnKVxuICAgICAgICAgICAgKyAnPiAnO1xuICAgIH1cbiAgICBwYXJhZ3JhcGgodGV4dCkge1xuICAgICAgICByZXR1cm4gYDxwPiR7dGV4dH08L3A+XFxuYDtcbiAgICB9XG4gICAgdGFibGUoaGVhZGVyLCBib2R5KSB7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgYm9keSA9IGA8dGJvZHk+JHtib2R5fTwvdGJvZHk+YDtcbiAgICAgICAgcmV0dXJuICc8dGFibGU+XFxuJ1xuICAgICAgICAgICAgKyAnPHRoZWFkPlxcbidcbiAgICAgICAgICAgICsgaGVhZGVyXG4gICAgICAgICAgICArICc8L3RoZWFkPlxcbidcbiAgICAgICAgICAgICsgYm9keVxuICAgICAgICAgICAgKyAnPC90YWJsZT5cXG4nO1xuICAgIH1cbiAgICB0YWJsZXJvdyhjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBgPHRyPlxcbiR7Y29udGVudH08L3RyPlxcbmA7XG4gICAgfVxuICAgIHRhYmxlY2VsbChjb250ZW50LCBmbGFncykge1xuICAgICAgICBjb25zdCB0eXBlID0gZmxhZ3MuaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gICAgICAgIGNvbnN0IHRhZyA9IGZsYWdzLmFsaWduXG4gICAgICAgICAgICA/IGA8JHt0eXBlfSBhbGlnbj1cIiR7ZmxhZ3MuYWxpZ259XCI+YFxuICAgICAgICAgICAgOiBgPCR7dHlwZX0+YDtcbiAgICAgICAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyBgPC8ke3R5cGV9PlxcbmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNwYW4gbGV2ZWwgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBzdHJvbmcodGV4dCkge1xuICAgICAgICByZXR1cm4gYDxzdHJvbmc+JHt0ZXh0fTwvc3Ryb25nPmA7XG4gICAgfVxuICAgIGVtKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8ZW0+JHt0ZXh0fTwvZW0+YDtcbiAgICB9XG4gICAgY29kZXNwYW4odGV4dCkge1xuICAgICAgICByZXR1cm4gYDxjb2RlPiR7dGV4dH08L2NvZGU+YDtcbiAgICB9XG4gICAgYnIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xuICAgIH1cbiAgICBkZWwodGV4dCkge1xuICAgICAgICByZXR1cm4gYDxkZWw+JHt0ZXh0fTwvZGVsPmA7XG4gICAgfVxuICAgIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgY29uc3QgY2xlYW5IcmVmID0gY2xlYW5VcmwodGhpcy5vcHRpb25zLnNhbml0aXplLCB0aGlzLm9wdGlvbnMuYmFzZVVybCwgaHJlZik7XG4gICAgICAgIGlmIChjbGVhbkhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgICAgIGxldCBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBocmVmID0gY2xlYW5IcmVmO1xuICAgICAgICBsZXQgb3V0ID0gYDxpbWcgc3JjPVwiJHtocmVmfVwiIGFsdD1cIiR7dGV4dH1cImA7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgb3V0ICs9IGAgdGl0bGU9XCIke3RpdGxlfVwiYDtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBUZXh0UmVuZGVyZXJcbiAqIHJldHVybnMgb25seSB0aGUgdGV4dHVhbCBwYXJ0IG9mIHRoZSB0b2tlblxuICovXG5jbGFzcyBfVGV4dFJlbmRlcmVyIHtcbiAgICAvLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcbiAgICBzdHJvbmcodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZW0odGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgY29kZXNwYW4odGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZGVsKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGh0bWwodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgdGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBsaW5rKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfVxuICAgIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfVxuICAgIGJyKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuXG4vKipcbiAqIFNsdWdnZXIgZ2VuZXJhdGVzIGhlYWRlciBpZFxuICovXG5jbGFzcyBfU2x1Z2dlciB7XG4gICAgc2VlbjtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZWVuID0ge307XG4gICAgfVxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAvLyByZW1vdmUgaHRtbCB0YWdzXG4gICAgICAgICAgICAucmVwbGFjZSgvPFshXFwvYS16XS4qPz4vaWcsICcnKVxuICAgICAgICAgICAgLy8gcmVtb3ZlIHVud2FudGVkIGNoYXJzXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTIwMDAtXFx1MjA2RlxcdTJFMDAtXFx1MkU3RlxcXFwnIVwiIyQlJigpKissLi86Ozw9Pj9AW1xcXV5ge3x9fl0vZywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzL2csICctJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBuZXh0IHNhZmUgKHVuaXF1ZSkgc2x1ZyB0byB1c2VcbiAgICAgKi9cbiAgICBnZXROZXh0U2FmZVNsdWcob3JpZ2luYWxTbHVnLCBpc0RyeVJ1bikge1xuICAgICAgICBsZXQgc2x1ZyA9IG9yaWdpbmFsU2x1ZztcbiAgICAgICAgbGV0IG9jY3VyZW5jZUFjY3VtdWxhdG9yID0gMDtcbiAgICAgICAgaWYgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xuICAgICAgICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBvY2N1cmVuY2VBY2N1bXVsYXRvcisrO1xuICAgICAgICAgICAgICAgIHNsdWcgPSBvcmlnaW5hbFNsdWcgKyAnLScgKyBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0RyeVJ1bikge1xuICAgICAgICAgICAgdGhpcy5zZWVuW29yaWdpbmFsU2x1Z10gPSBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgICAgICAgIHRoaXMuc2VlbltzbHVnXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsdWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgc3RyaW5nIHRvIHVuaXF1ZSBpZFxuICAgICAqL1xuICAgIHNsdWcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBzbHVnID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0U2FmZVNsdWcoc2x1Zywgb3B0aW9ucy5kcnlydW4pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cbmNsYXNzIF9QYXJzZXIge1xuICAgIG9wdGlvbnM7XG4gICAgcmVuZGVyZXI7XG4gICAgdGV4dFJlbmRlcmVyO1xuICAgIHNsdWdnZXI7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICAgICAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBfUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0aGlzLnRleHRSZW5kZXJlciA9IG5ldyBfVGV4dFJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuc2x1Z2dlciA9IG5ldyBfU2x1Z2dlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgX1BhcnNlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUlubGluZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgTG9vcFxuICAgICAqL1xuICAgIHBhcnNlKHRva2VucywgdG9wID0gdHJ1ZSkge1xuICAgICAgICBsZXQgb3V0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIC8vIFJ1biBhbnkgcmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVycyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmljVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZ2VuZXJpY1Rva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgZ2VuZXJpY1Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydzcGFjZScsICdocicsICdoZWFkaW5nJywgJ2NvZGUnLCAndGFibGUnLCAnYmxvY2txdW90ZScsICdsaXN0JywgJ2h0bWwnLCAncGFyYWdyYXBoJywgJ3RleHQnXS5pbmNsdWRlcyhnZW5lcmljVG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdocic6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2hlYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5oZWFkaW5nKHRoaXMucGFyc2VJbmxpbmUoaGVhZGluZ1Rva2VuLnRva2VucyksIGhlYWRpbmdUb2tlbi5kZXB0aCwgdW5lc2NhcGUodGhpcy5wYXJzZUlubGluZShoZWFkaW5nVG9rZW4udG9rZW5zLCB0aGlzLnRleHRSZW5kZXJlcikpLCB0aGlzLnNsdWdnZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnY29kZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZVRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmNvZGUoY29kZVRva2VuLnRleHQsIGNvZGVUb2tlbi5sYW5nLCAhIWNvZGVUb2tlbi5lc2NhcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RhYmxlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZVRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGxldCBoZWFkZXIgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFibGVUb2tlbi5oZWFkZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5wYXJzZUlubGluZSh0YWJsZVRva2VuLmhlYWRlcltqXS50b2tlbnMpLCB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRhYmxlVG9rZW4uYWxpZ25bal0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBib2R5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFibGVUb2tlbi5yb3dzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3cgPSB0YWJsZVRva2VuLnJvd3Nbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5wYXJzZUlubGluZShyb3dba10udG9rZW5zKSwgeyBoZWFkZXI6IGZhbHNlLCBhbGlnbjogdGFibGVUb2tlbi5hbGlnbltrXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2txdW90ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2txdW90ZVRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLnBhcnNlKGJsb2NrcXVvdGVUb2tlbi50b2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbGlzdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyZWQgPSBsaXN0VG9rZW4ub3JkZXJlZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBsaXN0VG9rZW4uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvb3NlID0gbGlzdFRva2VuLmxvb3NlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm9keSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3RUb2tlbi5pdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RUb2tlbi5pdGVtc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBpdGVtLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrID0gaXRlbS50YXNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW1Cb2R5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2tib3ggPSB0aGlzLnJlbmRlcmVyLmNoZWNrYm94KCEhY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zWzBdLnRva2VucyAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUJvZHkgKz0gY2hlY2tib3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUJvZHkgKz0gdGhpcy5wYXJzZShpdGVtLnRva2VucywgbG9vc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGl0ZW1Cb2R5LCB0YXNrLCAhIWNoZWNrZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaHRtbFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmh0bWwoaHRtbFRva2VuLnRleHQsIGh0bWxUb2tlbi5ibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFncmFwaFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLnBhcnNlSW5saW5lKHBhcmFncmFwaFRva2VuLnRva2VucykpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHRUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm9keSA9IHRleHRUb2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRleHRUb2tlbi50b2tlbnMpIDogdGV4dFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpICsgMSA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2kgKyAxXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRUb2tlbiA9IHRva2Vuc1srK2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSArPSAnXFxuJyArICh0ZXh0VG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0ZXh0VG9rZW4udG9rZW5zKSA6IHRleHRUb2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdG9wID8gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgoYm9keSkgOiBib2R5O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgSW5saW5lIFRva2Vuc1xuICAgICAqL1xuICAgIHBhcnNlSW5saW5lKHRva2VucywgcmVuZGVyZXIpIHtcbiAgICAgICAgcmVuZGVyZXIgPSByZW5kZXJlciB8fCB0aGlzLnJlbmRlcmVyO1xuICAgICAgICBsZXQgb3V0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIC8vIFJ1biBhbnkgcmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVycyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0uY2FsbCh7IHBhcnNlcjogdGhpcyB9LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gZmFsc2UgfHwgIVsnZXNjYXBlJywgJ2h0bWwnLCAnbGluaycsICdpbWFnZScsICdzdHJvbmcnLCAnZW0nLCAnY29kZXNwYW4nLCAnYnInLCAnZGVsJywgJ3RleHQnXS5pbmNsdWRlcyh0b2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmV0IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdlc2NhcGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZVRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KGVzY2FwZVRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmh0bWwodGFnVG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsaW5rJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmxpbmsobGlua1Rva2VuLmhyZWYsIGxpbmtUb2tlbi50aXRsZSwgdGhpcy5wYXJzZUlubGluZShsaW5rVG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmltYWdlKGltYWdlVG9rZW4uaHJlZiwgaW1hZ2VUb2tlbi50aXRsZSwgaW1hZ2VUb2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cm9uZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Ryb25nVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnN0cm9uZyh0aGlzLnBhcnNlSW5saW5lKHN0cm9uZ1Rva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2VtJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbVRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0aGlzLnBhcnNlSW5saW5lKGVtVG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnY29kZXNwYW4nOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVzcGFuVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmNvZGVzcGFuKGNvZGVzcGFuVG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdicic6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmJyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdkZWwnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5kZWwodGhpcy5wYXJzZUlubGluZShkZWxUb2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodGV4dFRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59XG5cbmNsYXNzIF9Ib29rcyB7XG4gICAgb3B0aW9ucztcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgIH1cbiAgICBzdGF0aWMgcGFzc1Rocm91Z2hIb29rcyA9IG5ldyBTZXQoW1xuICAgICAgICAncHJlcHJvY2VzcycsXG4gICAgICAgICdwb3N0cHJvY2VzcydcbiAgICBdKTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIG1hcmtkb3duIGJlZm9yZSBtYXJrZWRcbiAgICAgKi9cbiAgICBwcmVwcm9jZXNzKG1hcmtkb3duKSB7XG4gICAgICAgIHJldHVybiBtYXJrZG93bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBIVE1MIGFmdGVyIG1hcmtlZCBpcyBmaW5pc2hlZFxuICAgICAqL1xuICAgIHBvc3Rwcm9jZXNzKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxufVxuXG5jbGFzcyBNYXJrZWQge1xuICAgIGRlZmF1bHRzID0gX2dldERlZmF1bHRzKCk7XG4gICAgb3B0aW9ucyA9IHRoaXMuc2V0T3B0aW9ucztcbiAgICBwYXJzZSA9IHRoaXMuI3BhcnNlTWFya2Rvd24oX0xleGVyLmxleCwgX1BhcnNlci5wYXJzZSk7XG4gICAgcGFyc2VJbmxpbmUgPSB0aGlzLiNwYXJzZU1hcmtkb3duKF9MZXhlci5sZXhJbmxpbmUsIF9QYXJzZXIucGFyc2VJbmxpbmUpO1xuICAgIFBhcnNlciA9IF9QYXJzZXI7XG4gICAgcGFyc2VyID0gX1BhcnNlci5wYXJzZTtcbiAgICBSZW5kZXJlciA9IF9SZW5kZXJlcjtcbiAgICBUZXh0UmVuZGVyZXIgPSBfVGV4dFJlbmRlcmVyO1xuICAgIExleGVyID0gX0xleGVyO1xuICAgIGxleGVyID0gX0xleGVyLmxleDtcbiAgICBUb2tlbml6ZXIgPSBfVG9rZW5pemVyO1xuICAgIFNsdWdnZXIgPSBfU2x1Z2dlcjtcbiAgICBIb29rcyA9IF9Ib29rcztcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMudXNlKC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IHRva2VuXG4gICAgICovXG4gICAgd2Fsa1Rva2Vucyh0b2tlbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoY2FsbGJhY2suY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHRhYmxlVG9rZW4uaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhjZWxsLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZVRva2VuLnJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiByb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhjZWxsLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbGlzdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGxpc3RUb2tlbi5pdGVtcywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRzLmV4dGVuc2lvbnM/LmNoaWxkVG9rZW5zPy5bZ2VuZXJpY1Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRzLmV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZ2VuZXJpY1Rva2VuLnR5cGVdLmZvckVhY2goKGNoaWxkVG9rZW5zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoZ2VuZXJpY1Rva2VuW2NoaWxkVG9rZW5zXSwgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGdlbmVyaWNUb2tlbi50b2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGdlbmVyaWNUb2tlbi50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgdXNlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucyB8fCB7IHJlbmRlcmVyczoge30sIGNoaWxkVG9rZW5zOiB7fSB9O1xuICAgICAgICBhcmdzLmZvckVhY2goKHBhY2spID0+IHtcbiAgICAgICAgICAgIC8vIGNvcHkgb3B0aW9ucyB0byBuZXcgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCBvcHRzID0geyAuLi5wYWNrIH07XG4gICAgICAgICAgICAvLyBzZXQgYXN5bmMgdG8gdHJ1ZSBpZiBpdCB3YXMgc2V0IHRvIHRydWUgYmVmb3JlXG4gICAgICAgICAgICBvcHRzLmFzeW5jID0gdGhpcy5kZWZhdWx0cy5hc3luYyB8fCBvcHRzLmFzeW5jIHx8IGZhbHNlO1xuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBcImFkZG9uXCIgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay5leHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgcGFjay5leHRlbnNpb25zLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuc2lvbiBuYW1lIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdyZW5kZXJlcicgaW4gZXh0KSB7IC8vIFJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2UmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV4dGVuc2lvbiB3aXRoIGZ1bmMgdG8gcnVuIG5ldyBleHRlbnNpb24gYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSBleHQucmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdID0gZXh0LnJlbmRlcmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgndG9rZW5pemVyJyBpbiBleHQpIHsgLy8gVG9rZW5pemVyIEV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXh0LmxldmVsIHx8IChleHQubGV2ZWwgIT09ICdibG9jaycgJiYgZXh0LmxldmVsICE9PSAnaW5saW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHRlbnNpb24gbGV2ZWwgbXVzdCBiZSAnYmxvY2snIG9yICdpbmxpbmUnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0TGV2ZWwgPSBleHRlbnNpb25zW2V4dC5sZXZlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRMZXZlbC51bnNoaWZ0KGV4dC50b2tlbml6ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdID0gW2V4dC50b2tlbml6ZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dC5zdGFydCkgeyAvLyBGdW5jdGlvbiB0byBjaGVjayBmb3Igc3RhcnQgb2YgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0LmxldmVsID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRCbG9jay5wdXNoKGV4dC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChleHQubGV2ZWwgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ2NoaWxkVG9rZW5zJyBpbiBleHQgJiYgZXh0LmNoaWxkVG9rZW5zKSB7IC8vIENoaWxkIHRva2VucyB0byBiZSB2aXNpdGVkIGJ5IHdhbGtUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZXh0Lm5hbWVdID0gZXh0LmNoaWxkVG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3B0cy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vID09LS0gUGFyc2UgXCJvdmVyd3JpdGVcIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmRlZmF1bHRzLnJlbmRlcmVyIHx8IG5ldyBfUmVuZGVyZXIodGhpcy5kZWZhdWx0cyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJGdW5jID0gcGFjay5yZW5kZXJlcltwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJLZXkgPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2UmVuZGVyZXIgPSByZW5kZXJlcltyZW5kZXJlcktleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgcmVuZGVyZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJbcmVuZGVyZXJLZXldID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSByZW5kZXJlckZ1bmMuYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyID0gdGhpcy5kZWZhdWx0cy50b2tlbml6ZXIgfHwgbmV3IF9Ub2tlbml6ZXIodGhpcy5kZWZhdWx0cyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuaXplckZ1bmMgPSBwYWNrLnRva2VuaXplcltwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyS2V5ID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlRva2VuaXplciA9IHRva2VuaXplclt0b2tlbml6ZXJLZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRva2VuaXplciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZXJbdG9rZW5pemVyS2V5XSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gdG9rZW5pemVyRnVuYy5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2VG9rZW5pemVyLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vID09LS0gUGFyc2UgSG9va3MgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay5ob29rcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tzID0gdGhpcy5kZWZhdWx0cy5ob29rcyB8fCBuZXcgX0hvb2tzKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2suaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NGdW5jID0gcGFjay5ob29rc1twcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NLZXkgPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2SG9vayA9IGhvb2tzW2hvb2tzS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9Ib29rcy5wYXNzVGhyb3VnaEhvb2tzLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NLZXldID0gKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRzLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaG9va3NGdW5jLmNhbGwoaG9va3MsIGFyZykpLnRoZW4ocmV0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SG9vay5jYWxsKGhvb2tzLCByZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gaG9va3NGdW5jLmNhbGwoaG9va3MsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZIb29rLmNhbGwoaG9va3MsIHJldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NLZXldID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gaG9va3NGdW5jLmFwcGx5KGhvb2tzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2SG9vay5hcHBseShob29rcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdHMuaG9va3MgPSBob29rcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vID09LS0gUGFyc2UgV2Fsa1Rva2VucyBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLndhbGtUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YWxrVG9rZW5zID0gdGhpcy5kZWZhdWx0cy53YWxrVG9rZW5zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tXYWxrdG9rZW5zID0gcGFjay53YWxrVG9rZW5zO1xuICAgICAgICAgICAgICAgIG9wdHMud2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHBhY2tXYWxrdG9rZW5zLmNhbGwodGhpcywgdG9rZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGtUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQod2Fsa1Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4ub3B0cyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0KSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9wdCB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgI3BhcnNlTWFya2Rvd24obGV4ZXIsIHBhcnNlcikge1xuICAgICAgICByZXR1cm4gKHNyYywgb3B0T3JDYWxsYmFjaywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0T3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0T3JDYWxsYmFjaztcbiAgICAgICAgICAgICAgICBvcHRPckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9yaWdPcHQgPSB7IC4uLm9wdE9yQ2FsbGJhY2sgfTtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4ub3JpZ09wdCB9O1xuICAgICAgICAgICAgLy8gU2hvdyB3YXJuaW5nIGlmIGFuIGV4dGVuc2lvbiBzZXQgYXN5bmMgdG8gdHJ1ZSBidXQgdGhlIHBhcnNlIHdhcyBjYWxsZWQgd2l0aCBhc3luYzogZmFsc2VcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRzLmFzeW5jID09PSB0cnVlICYmIG9yaWdPcHQuYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IFRoZSBhc3luYyBvcHRpb24gd2FzIHNldCB0byB0cnVlIGJ5IGFuIGV4dGVuc2lvbi4gVGhlIGFzeW5jOiBmYWxzZSBvcHRpb24gc2VudCB0byBwYXJzZSB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdC5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aHJvd0Vycm9yID0gdGhpcy4jb25FcnJvcighIW9wdC5zaWxlbnQsICEhb3B0LmFzeW5jLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSAnXG4gICAgICAgICAgICAgICAgICAgICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgKyAnLCBzdHJpbmcgZXhwZWN0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0RlcHJlY2F0aW9ucyhvcHQsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICBvcHQuaG9va3Mub3B0aW9ucyA9IG9wdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodDtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5zO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IG9wdC5ob29rcy5wcmVwcm9jZXNzKHNyYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gbGV4ZXIoc3JjLCBvcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZG9uZSA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG91dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gcGFyc2VyKHRva2Vucywgb3B0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRocm93RXJyb3IoZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXN1bHRDYWxsYmFjayhudWxsLCBvdXQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCFoaWdobGlnaHQgfHwgaGlnaGxpZ2h0Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdC5oaWdobGlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICAgICAgICAgIGxldCBwZW5kaW5nID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtUb2tlbnModG9rZW5zLCAodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdjb2RlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIChlcnIsIGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPSBudWxsICYmIGNvZGUgIT09IHRva2VuLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByZXByb2Nlc3Moc3JjKSA6IHNyYylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oc3JjID0+IGxleGVyKHNyYywgb3B0KSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW5zID0+IG9wdC53YWxrVG9rZW5zID8gUHJvbWlzZS5hbGwodGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpKS50aGVuKCgpID0+IHRva2VucykgOiB0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRva2VucyA9PiBwYXJzZXIodG9rZW5zLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihodG1sID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKSA6IGh0bWwpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aHJvd0Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBsZXhlcihzcmMsIG9wdCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGh0bWwgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAjb25FcnJvcihzaWxlbnQsIGFzeW5jLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWQuJztcbiAgICAgICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+J1xuICAgICAgICAgICAgICAgICAgICArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgKyAnPC9wcmU+JztcbiAgICAgICAgICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNvbnN0IG1hcmtlZEluc3RhbmNlID0gbmV3IE1hcmtlZCgpO1xuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBtYXJrZWRJbnN0YW5jZS5wYXJzZShzcmMsIG9wdCwgY2FsbGJhY2spO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgSGFzaCBvZiBvcHRpb25zXG4gKi9cbm1hcmtlZC5vcHRpb25zID1cbiAgICBtYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG1hcmtlZEluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIG1hcmtlZC5kZWZhdWx0cyA9IG1hcmtlZEluc3RhbmNlLmRlZmF1bHRzO1xuICAgICAgICBjaGFuZ2VEZWZhdWx0cyhtYXJrZWQuZGVmYXVsdHMpO1xuICAgICAgICByZXR1cm4gbWFya2VkO1xuICAgIH07XG4vKipcbiAqIEdldHMgdGhlIG9yaWdpbmFsIG1hcmtlZCBkZWZhdWx0IG9wdGlvbnMuXG4gKi9cbm1hcmtlZC5nZXREZWZhdWx0cyA9IF9nZXREZWZhdWx0cztcbm1hcmtlZC5kZWZhdWx0cyA9IF9kZWZhdWx0cztcbi8qKlxuICogVXNlIEV4dGVuc2lvblxuICovXG5tYXJrZWQudXNlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBtYXJrZWRJbnN0YW5jZS51c2UoLi4uYXJncyk7XG4gICAgbWFya2VkLmRlZmF1bHRzID0gbWFya2VkSW5zdGFuY2UuZGVmYXVsdHM7XG4gICAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgICByZXR1cm4gbWFya2VkO1xufTtcbi8qKlxuICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICovXG5tYXJrZWQud2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLndhbGtUb2tlbnModG9rZW5zLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBDb21waWxlcyBtYXJrZG93biB0byBIVE1MIHdpdGhvdXQgZW5jbG9zaW5nIGBwYCB0YWcuXG4gKlxuICogQHBhcmFtIHNyYyBTdHJpbmcgb2YgbWFya2Rvd24gc291cmNlIHRvIGJlIGNvbXBpbGVkXG4gKiBAcGFyYW0gb3B0aW9ucyBIYXNoIG9mIG9wdGlvbnNcbiAqIEByZXR1cm4gU3RyaW5nIG9mIGNvbXBpbGVkIEhUTUxcbiAqL1xubWFya2VkLnBhcnNlSW5saW5lID0gbWFya2VkSW5zdGFuY2UucGFyc2VJbmxpbmU7XG4vKipcbiAqIEV4cG9zZVxuICovXG5tYXJrZWQuUGFyc2VyID0gX1BhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xubWFya2VkLlJlbmRlcmVyID0gX1JlbmRlcmVyO1xubWFya2VkLlRleHRSZW5kZXJlciA9IF9UZXh0UmVuZGVyZXI7XG5tYXJrZWQuTGV4ZXIgPSBfTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBfTGV4ZXIubGV4O1xubWFya2VkLlRva2VuaXplciA9IF9Ub2tlbml6ZXI7XG5tYXJrZWQuU2x1Z2dlciA9IF9TbHVnZ2VyO1xubWFya2VkLkhvb2tzID0gX0hvb2tzO1xubWFya2VkLnBhcnNlID0gbWFya2VkO1xuY29uc3Qgb3B0aW9ucyA9IG1hcmtlZC5vcHRpb25zO1xuY29uc3Qgc2V0T3B0aW9ucyA9IG1hcmtlZC5zZXRPcHRpb25zO1xuY29uc3QgdXNlID0gbWFya2VkLnVzZTtcbmNvbnN0IHdhbGtUb2tlbnMgPSBtYXJrZWQud2Fsa1Rva2VucztcbmNvbnN0IHBhcnNlSW5saW5lID0gbWFya2VkLnBhcnNlSW5saW5lO1xuY29uc3QgcGFyc2UgPSBtYXJrZWQ7XG5jb25zdCBwYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xuY29uc3QgbGV4ZXIgPSBfTGV4ZXIubGV4O1xuXG5leHBvcnQgeyBfSG9va3MgYXMgSG9va3MsIF9MZXhlciBhcyBMZXhlciwgTWFya2VkLCBfUGFyc2VyIGFzIFBhcnNlciwgX1JlbmRlcmVyIGFzIFJlbmRlcmVyLCBfU2x1Z2dlciBhcyBTbHVnZ2VyLCBfVGV4dFJlbmRlcmVyIGFzIFRleHRSZW5kZXJlciwgX1Rva2VuaXplciBhcyBUb2tlbml6ZXIsIF9kZWZhdWx0cyBhcyBkZWZhdWx0cywgX2dldERlZmF1bHRzIGFzIGdldERlZmF1bHRzLCBsZXhlciwgbWFya2VkLCBvcHRpb25zLCBwYXJzZSwgcGFyc2VJbmxpbmUsIHBhcnNlciwgc2V0T3B0aW9ucywgdXNlLCB3YWxrVG9rZW5zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXJrZWQuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9nZXREZWZhdWx0cyIsImFzeW5jIiwiYmFzZVVybCIsImJyZWFrcyIsImV4dGVuc2lvbnMiLCJnZm0iLCJoZWFkZXJJZHMiLCJoZWFkZXJQcmVmaXgiLCJoaWdobGlnaHQiLCJob29rcyIsImxhbmdQcmVmaXgiLCJtYW5nbGUiLCJwZWRhbnRpYyIsInJlbmRlcmVyIiwic2FuaXRpemUiLCJzYW5pdGl6ZXIiLCJzaWxlbnQiLCJzbWFydHlwYW50cyIsInRva2VuaXplciIsIndhbGtUb2tlbnMiLCJ4aHRtbCIsIl9kZWZhdWx0cyIsImNoYW5nZURlZmF1bHRzIiwibmV3RGVmYXVsdHMiLCJlc2NhcGVUZXN0IiwiZXNjYXBlUmVwbGFjZSIsIlJlZ0V4cCIsInNvdXJjZSIsImVzY2FwZVRlc3ROb0VuY29kZSIsImVzY2FwZVJlcGxhY2VOb0VuY29kZSIsImVzY2FwZVJlcGxhY2VtZW50cyIsImdldEVzY2FwZVJlcGxhY2VtZW50IiwiY2giLCJlc2NhcGUiLCJodG1sIiwiZW5jb2RlIiwidGVzdCIsInJlcGxhY2UiLCJ1bmVzY2FwZVRlc3QiLCJ1bmVzY2FwZSIsIl8iLCJuIiwidG9Mb3dlckNhc2UiLCJjaGFyQXQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImNhcmV0IiwiZWRpdCIsInJlZ2V4Iiwib3B0Iiwib2JqIiwibmFtZSIsInZhbCIsImdldFJlZ2V4Iiwibm9uV29yZEFuZENvbG9uVGVzdCIsIm9yaWdpbkluZGVwZW5kZW50VXJsIiwiY2xlYW5VcmwiLCJiYXNlIiwiaHJlZiIsInByb3QiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlIiwiaW5kZXhPZiIsInJlc29sdmVVcmwiLCJlbmNvZGVVUkkiLCJiYXNlVXJscyIsImp1c3REb21haW4iLCJwcm90b2NvbCIsImRvbWFpbiIsInJ0cmltIiwicmVsYXRpdmVCYXNlIiwibm9vcFRlc3QiLCJleGVjIiwic3BsaXRDZWxscyIsInRhYmxlUm93IiwiY291bnQiLCJyb3ciLCJtYXRjaCIsIm9mZnNldCIsInN0ciIsImVzY2FwZWQiLCJjdXJyIiwiY2VsbHMiLCJzcGxpdCIsImkiLCJ0cmltIiwic2hpZnQiLCJsZW5ndGgiLCJwb3AiLCJzcGxpY2UiLCJwdXNoIiwiYyIsImludmVydCIsImwiLCJzdWZmTGVuIiwiY3VyckNoYXIiLCJzbGljZSIsImZpbmRDbG9zaW5nQnJhY2tldCIsImIiLCJsZXZlbCIsImNoZWNrRGVwcmVjYXRpb25zIiwiY2FsbGJhY2siLCJjb25zb2xlIiwid2FybiIsIm91dHB1dExpbmsiLCJjYXAiLCJsaW5rIiwicmF3IiwibGV4ZXIiLCJ0aXRsZSIsInRleHQiLCJzdGF0ZSIsImluTGluayIsInRva2VuIiwidHlwZSIsInRva2VucyIsImlubGluZVRva2VucyIsImluZGVudENvZGVDb21wZW5zYXRpb24iLCJtYXRjaEluZGVudFRvQ29kZSIsImluZGVudFRvQ29kZSIsIm1hcCIsIm5vZGUiLCJtYXRjaEluZGVudEluTm9kZSIsImluZGVudEluTm9kZSIsImpvaW4iLCJfVG9rZW5pemVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwic3BhY2UiLCJzcmMiLCJydWxlcyIsImJsb2NrIiwibmV3bGluZSIsImNvZGUiLCJjb2RlQmxvY2tTdHlsZSIsImZlbmNlcyIsImxhbmciLCJpbmxpbmUiLCJfZXNjYXBlcyIsImhlYWRpbmciLCJ0cmltbWVkIiwiZGVwdGgiLCJociIsImJsb2NrcXVvdGUiLCJ0b3AiLCJibG9ja1Rva2VucyIsImxpc3QiLCJidWxsIiwiaXNvcmRlcmVkIiwib3JkZXJlZCIsInN0YXJ0IiwibG9vc2UiLCJpdGVtcyIsIml0ZW1SZWdleCIsIml0ZW1Db250ZW50cyIsImVuZHNXaXRoQmxhbmtMaW5lIiwiZW5kRWFybHkiLCJsaW5lIiwidCIsInJlcGVhdCIsIm5leHRMaW5lIiwiaW5kZW50IiwidHJpbUxlZnQiLCJzZWFyY2giLCJibGFua0xpbmUiLCJuZXh0QnVsbGV0UmVnZXgiLCJNYXRoIiwibWluIiwiaHJSZWdleCIsImZlbmNlc0JlZ2luUmVnZXgiLCJoZWFkaW5nQmVnaW5SZWdleCIsInJhd0xpbmUiLCJpc3Rhc2siLCJpc2NoZWNrZWQiLCJ0YXNrIiwiY2hlY2tlZCIsInRyaW1SaWdodCIsInNwYWNlcnMiLCJmaWx0ZXIiLCJoYXNNdWx0aXBsZUxpbmVCcmVha3MiLCJzb21lIiwicHJlIiwicGFyYWdyYXBoIiwiZGVmIiwidGFnIiwidGFibGUiLCJpdGVtIiwiaGVhZGVyIiwiYWxpZ24iLCJyb3dzIiwiaiIsImsiLCJsaGVhZGluZyIsImluUmF3QmxvY2siLCJ0cmltbWVkVXJsIiwicnRyaW1TbGFzaCIsImxhc3RQYXJlbkluZGV4IiwibGlua0xlbiIsInJlZmxpbmsiLCJsaW5rcyIsIm5vbGluayIsImVtU3Ryb25nIiwibWFza2VkU3JjIiwicHJldkNoYXIiLCJsRGVsaW0iLCJuZXh0Q2hhciIsInB1bmN0dWF0aW9uIiwibExlbmd0aCIsInJEZWxpbSIsInJMZW5ndGgiLCJkZWxpbVRvdGFsIiwibWlkRGVsaW1Ub3RhbCIsImVuZFJlZyIsInJEZWxpbUFzdCIsInJEZWxpbVVuZCIsImxhc3RJbmRleCIsImluZGV4IiwiY29kZXNwYW4iLCJoYXNOb25TcGFjZUNoYXJzIiwiaGFzU3BhY2VDaGFyc09uQm90aEVuZHMiLCJiciIsImRlbCIsImF1dG9saW5rIiwidXJsIiwicHJldkNhcFplcm8iLCJfYmFja3BlZGFsIiwiaW5saW5lVGV4dCIsIl9wYXJhZ3JhcGgiLCJfbGFiZWwiLCJfdGl0bGUiLCJidWxsZXQiLCJsaXN0SXRlbVN0YXJ0IiwiX3RhZyIsIl9jb21tZW50Iiwibm9ybWFsIiwicmVmbGlua1NlYXJjaCIsIl9wdW5jdHVhdGlvbiIsImJsb2NrU2tpcCIsImFueVB1bmN0dWF0aW9uIiwiX3NjaGVtZSIsIl9lbWFpbCIsIl9hdHRyaWJ1dGUiLCJfaHJlZiIsInN0cm9uZyIsIm1pZGRsZSIsImVuZEFzdCIsImVuZFVuZCIsImVtIiwiX2V4dGVuZGVkX2VtYWlsIiwib3V0IiwicmFuZG9tIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwiX0xleGVyIiwiT2JqZWN0IiwiY3JlYXRlIiwiaW5saW5lUXVldWUiLCJsZXgiLCJsZXhJbmxpbmUiLCJuZXh0IiwibGVhZGluZyIsInRhYnMiLCJsYXN0VG9rZW4iLCJjdXRTcmMiLCJsYXN0UGFyYWdyYXBoQ2xpcHBlZCIsImV4dFRva2VuaXplciIsImNhbGwiLCJzdGFydEJsb2NrIiwic3RhcnRJbmRleCIsIkluZmluaXR5IiwidGVtcFNyYyIsInRlbXBTdGFydCIsImZvckVhY2giLCJnZXRTdGFydEluZGV4IiwiZXJyTXNnIiwiZXJyb3IiLCJFcnJvciIsImtlZXBQcmV2Q2hhciIsImtleXMiLCJpbmNsdWRlcyIsImxhc3RJbmRleE9mIiwic3RhcnRJbmxpbmUiLCJfUmVuZGVyZXIiLCJpbmZvc3RyaW5nIiwicXVvdGUiLCJzbHVnZ2VyIiwiaWQiLCJzbHVnIiwiYm9keSIsInN0YXJ0YXR0IiwibGlzdGl0ZW0iLCJjaGVja2JveCIsInRhYmxlcm93IiwiY29udGVudCIsInRhYmxlY2VsbCIsImZsYWdzIiwiY2xlYW5IcmVmIiwiaW1hZ2UiLCJfVGV4dFJlbmRlcmVyIiwiX1NsdWdnZXIiLCJzZWVuIiwic2VyaWFsaXplIiwidmFsdWUiLCJnZXROZXh0U2FmZVNsdWciLCJvcmlnaW5hbFNsdWciLCJpc0RyeVJ1biIsIm9jY3VyZW5jZUFjY3VtdWxhdG9yIiwiaGFzT3duUHJvcGVydHkiLCJkcnlydW4iLCJfUGFyc2VyIiwidGV4dFJlbmRlcmVyIiwicGFyc2UiLCJwYXJzZXIiLCJwYXJzZUlubGluZSIsInJlbmRlcmVycyIsImdlbmVyaWNUb2tlbiIsInJldCIsImhlYWRpbmdUb2tlbiIsImNvZGVUb2tlbiIsInRhYmxlVG9rZW4iLCJjZWxsIiwiYmxvY2txdW90ZVRva2VuIiwibGlzdFRva2VuIiwiaXRlbUJvZHkiLCJ1bnNoaWZ0IiwiaHRtbFRva2VuIiwicGFyYWdyYXBoVG9rZW4iLCJ0ZXh0VG9rZW4iLCJlc2NhcGVUb2tlbiIsInRhZ1Rva2VuIiwibGlua1Rva2VuIiwiaW1hZ2VUb2tlbiIsInN0cm9uZ1Rva2VuIiwiZW1Ub2tlbiIsImNvZGVzcGFuVG9rZW4iLCJkZWxUb2tlbiIsIl9Ib29rcyIsInBhc3NUaHJvdWdoSG9va3MiLCJTZXQiLCJwcmVwcm9jZXNzIiwibWFya2Rvd24iLCJwb3N0cHJvY2VzcyIsIk1hcmtlZCIsImFyZ3MiLCJkZWZhdWx0cyIsInNldE9wdGlvbnMiLCJwYXJzZU1hcmtkb3duIiwiUGFyc2VyIiwiUmVuZGVyZXIiLCJUZXh0UmVuZGVyZXIiLCJMZXhlciIsIlRva2VuaXplciIsIlNsdWdnZXIiLCJIb29rcyIsInVzZSIsInZhbHVlcyIsImNvbmNhdCIsImNoaWxkVG9rZW5zIiwicGFjayIsIm9wdHMiLCJleHQiLCJwcmV2UmVuZGVyZXIiLCJhcHBseSIsImV4dExldmVsIiwicHJvcCIsInJlbmRlcmVyRnVuYyIsInJlbmRlcmVyS2V5IiwidG9rZW5pemVyRnVuYyIsInRva2VuaXplcktleSIsInByZXZUb2tlbml6ZXIiLCJob29rc0Z1bmMiLCJob29rc0tleSIsInByZXZIb29rIiwiaGFzIiwiYXJnIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicGFja1dhbGt0b2tlbnMiLCJvcHRPckNhbGxiYWNrIiwib3JpZ09wdCIsInRocm93RXJyb3IiLCJvbkVycm9yIiwicHJvdG90eXBlIiwicmVzdWx0Q2FsbGJhY2siLCJkb25lIiwiZXJyIiwicGVuZGluZyIsInNldFRpbWVvdXQiLCJhbGwiLCJjYXRjaCIsIm1lc3NhZ2UiLCJtc2ciLCJyZWplY3QiLCJtYXJrZWRJbnN0YW5jZSIsIm1hcmtlZCIsImdldERlZmF1bHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/marked/lib/marked.esm.js\n");

/***/ })

};
;